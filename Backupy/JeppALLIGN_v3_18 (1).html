<!DOCTYPE html>
<html lang="pl">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>JeppALLIGN v3.18 - Loop Diagnostics</title>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/pdf.js/3.11.174/pdf.min.js"></script>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            min-height: 100vh;
        }

        .container {
            max-width: 95vw;  /* v3.17: Zwiƒôkszone z 1800px - nie ograniczaj du≈ºych map */
            margin: 0 auto;
            padding: 20px;
        }

        .header {
            background: white;
            padding: 20px;
            border-radius: 15px;
            box-shadow: 0 10px 40px rgba(0,0,0,0.2);
            margin-bottom: 20px;
            text-align: center;
        }

        .header h1 {
            color: #667eea;
            font-size: 2.5em;
            margin-bottom: 5px;
        }

        .header p {
            color: #666;
            font-size: 1.1em;
        }

        .version-badge {
            display: inline-block;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
            padding: 5px 15px;
            border-radius: 20px;
            font-weight: bold;
            margin-top: 10px;
        }

        .upload-section {
            background: white;
            padding: 40px;
            border-radius: 15px;
            box-shadow: 0 10px 40px rgba(0,0,0,0.2);
            margin-bottom: 20px;
        }

        .upload-grid {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 30px;
            margin-bottom: 30px;
        }

        .drop-zone {
            border: 3px dashed #ccc;
            border-radius: 15px;
            padding: 40px;
            text-align: center;
            cursor: pointer;
            transition: all 0.3s ease;
            background: #f8f9fa;
        }

        .drop-zone:hover {
            border-color: #667eea;
            background: #f0f4ff;
        }

        .drop-zone.drag-over {
            border-color: #667eea;
            background: #e8f0ff;
            transform: scale(1.02);
        }

        .drop-zone-icon {
            font-size: 4em;
            margin-bottom: 15px;
        }

        .drop-zone-text {
            font-size: 1.3em;
            font-weight: bold;
            margin-bottom: 10px;
        }

        .file-input {
            display: none;
        }

        .btn {
            padding: 15px 30px;
            border: none;
            border-radius: 10px;
            cursor: pointer;
            font-size: 1.1em;
            font-weight: bold;
            transition: all 0.3s ease;
            color: white;
        }

        .btn-primary {
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
        }

        .btn-primary:hover {
            transform: translateY(-2px);
            box-shadow: 0 5px 20px rgba(102, 126, 234, 0.4);
        }

        .loading {
            display: none;
            text-align: center;
            padding: 40px;
            background: white;
            border-radius: 15px;
            box-shadow: 0 10px 40px rgba(0,0,0,0.2);
        }

        .progress-bar-container {
            width: 100%;
            max-width: 600px;
            height: 30px;
            background: #f3f3f3;
            border-radius: 15px;
            overflow: hidden;
            margin: 20px auto;
            position: relative;
        }

        .progress-bar {
            height: 100%;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            width: 0%;
            transition: width 0.3s ease;
            position: relative;
        }

        .progress-text {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            font-weight: bold;
            color: #333;
        }

        .comparison-section {
            display: none;
        }

        .comparison-grid {
            display: grid;
            grid-template-columns: 300px 1fr;
            gap: 20px;
        }

        .control-panel {
            background: white;
            padding: 20px;
            border-radius: 15px;
            box-shadow: 0 10px 40px rgba(0,0,0,0.2);
            height: fit-content;
        }

        .control-panel h3 {
            color: #667eea;
            margin-bottom: 15px;
            padding-bottom: 10px;
            border-bottom: 2px solid #667eea;
        }

        .control-group {
            margin-bottom: 20px;
        }

        .control-group label {
            display: block;
            font-weight: bold;
            margin-bottom: 5px;
            color: #333;
        }

        .control-group input[type="range"] {
            width: 100%;
            margin-bottom: 5px;
        }

        .control-group .value-display {
            text-align: center;
            color: #666;
            font-size: 0.9em;
        }

        .btn-control {
            width: 100%;
            padding: 10px;
            margin-bottom: 10px;
            border: 2px solid #667eea;
            background: white;
            color: #667eea;
            border-radius: 8px;
            cursor: pointer;
            font-weight: bold;
            transition: all 0.3s ease;
        }

        .btn-control:hover {
            background: #667eea;
            color: white;
        }

        .btn-control.active {
            background: #667eea;
            color: white;
        }

        .viewer-area {
            background: white;
            border-radius: 15px;
            box-shadow: 0 10px 40px rgba(0,0,0,0.2);
            overflow: auto;  /* v3.18: Scroll gdy canvas wiƒôkszy ni≈º viewport */
            min-height: 800px;  /* WystarczajƒÖco du≈ºy dla wiƒôkszo≈õci map */
            max-height: calc(100vh - 200px);  /* Nie zajmuje ca≈Çego ekranu */
        }

        .viewer-header {
            background: #f8f9fa;
            padding: 15px;
            border-bottom: 2px solid #dee2e6;
            display: flex;
            justify-content: space-between;
            align-items: center;
        }

        .page-nav {
            display: flex;
            gap: 10px;
            align-items: center;
        }

        .page-nav button {
            padding: 8px 16px;
            background: #667eea;
            color: white;
            border: none;
            border-radius: 5px;
            cursor: pointer;
            font-weight: bold;
        }

        .page-nav button:disabled {
            background: #ccc;
            cursor: not-allowed;
        }

        .viewer-wrapper {
            position: relative;
            min-height: 600px;  /* v3.18: Zmniejszone z 800px */
            height: auto;
            overflow: visible;  /* Canvas mo≈ºe wychodziƒá poza wrapper */
            background: #e9ecef;
            display: flex;
            align-items: center;
            justify-content: center;
            padding: 20px;  /* v3.18: Padding dla canvas */
        }

        .canvas-container {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            cursor: grab;
        }

        .canvas-container:active {
            cursor: grabbing;
        }

        .canvas-container canvas {
            display: block;
            box-shadow: 0 5px 20px rgba(0,0,0,0.3);
        }

        .label {
            position: absolute;
            top: 10px;
            right: 10px;
            padding: 10px 20px;
            border-radius: 8px;
            font-weight: bold;
            font-size: 1.2em;
            pointer-events: none;
            z-index: 1000;
        }

        .label.old {
            background: #dc3545;
            color: white;
        }

        .label.new {
            background: #28a745;
            color: white;
        }

        .frame-overlay {
            position: absolute;
            border: 3px solid yellow;
            pointer-events: none;
            z-index: 999;
        }

        .alignment-info {
            background: #fff3cd;
            padding: 10px;
            border-radius: 5px;
            margin-top: 10px;
            font-size: 0.9em;
        }

        .alignment-info div {
            margin: 3px 0;
        }
    </style>
</head>
<body>
    <div class="container">
        <div class="header">
            <h1>‚úàÔ∏è JeppALLIGN</h1>
            <p>Professional Chart Frame Alignment Tool</p>
            <div class="version-badge">v3.15 - Edge Consistency & Outermost Frame</div>
            <p style="font-size: 0.9em; color: #888; margin-top: 10px;">
                ‚úÖ Perfect overlay ‚Ä¢ üéØ Edge Consistency Filter ‚Ä¢ üìê Rectangularity Check (90¬∞ ¬±2¬∞)
            </p>
        </div>

        <div class="upload-section" id="uploadSection">
            <div class="upload-grid">
                <div>
                    <h3 style="text-align: center; color: #dc3545; margin-bottom: 15px;">üìÑ OLD MAP</h3>
                    <div class="drop-zone" id="dropZoneOld" style="border-color: #dc3545;">
                        <div class="drop-zone-icon">üì•</div>
                        <div class="drop-zone-text" style="color: #dc3545;">PrzeciƒÖgnij plik OLD tutaj</div>
                    </div>
                    <button class="btn btn-primary" onclick="document.getElementById('oldFileInput').click()" style="width: 100%; margin-top: 15px; background: #dc3545;">
                        üìÇ Wybierz plik OLD
                    </button>
                    <div id="oldFileName" style="margin-top: 10px; text-align: center; color: #666;">Nie za≈Çadowano</div>
                </div>

                <div>
                    <h3 style="text-align: center; color: #28a745; margin-bottom: 15px;">üìÑ NEW MAP</h3>
                    <div class="drop-zone" id="dropZoneNew" style="border-color: #28a745;">
                        <div class="drop-zone-icon">üì•</div>
                        <div class="drop-zone-text" style="color: #28a745;">PrzeciƒÖgnij plik NEW tutaj</div>
                    </div>
                    <button class="btn btn-primary" onclick="document.getElementById('newFileInput').click()" style="width: 100%; margin-top: 15px; background: #28a745;">
                        üìÇ Wybierz plik NEW
                    </button>
                    <div id="newFileName" style="margin-top: 10px; text-align: center; color: #666;">Nie za≈Çadowano</div>
                </div>
            </div>

            <div id="startButtonContainer" style="text-align: center; display: none;">
                <button class="btn btn-primary" onclick="startComparison()" style="padding: 20px 50px; font-size: 1.3em;">
                    üöÄ Start Alignment Test
                </button>
            </div>

            <input type="file" id="oldFileInput" class="file-input" accept=".pdf">
            <input type="file" id="newFileInput" class="file-input" accept=".pdf">
        </div>

        <div class="loading" id="loading">
            <div class="progress-bar-container">
                <div class="progress-bar" id="progressBar"></div>
                <div class="progress-text" id="progressText">0%</div>
            </div>
            <p id="loadingText">≈Åadowanie i analiza ramek...</p>
        </div>

        <div class="comparison-section" id="comparisonSection">
            <div class="comparison-grid">
                <div class="control-panel">
                    <h3>‚öôÔ∏è Frame Detection Settings</h3>

                    <div class="control-group">
                        <label>Edge Threshold: <span id="edgeThresholdValue">12</span></label>
                        <input type="range" id="edgeThreshold" min="5" max="50" value="12" oninput="updateThreshold()">
                        <div class="value-display">Ni≈ºsza warto≈õƒá = wiƒôcej krawƒôdzi</div>
                    </div>

                    <div class="control-group">
                        <label>Gap Tolerance: <span id="gapToleranceValue">5</span>px</label>
                        <input type="range" id="gapTolerance" min="2" max="30" value="5" oninput="updateThreshold()">
                        <div class="value-display">Max przerwa w linii ramki</div>
                    </div>

                    <div class="control-group">
                        <label>Line Threshold: <span id="lineThresholdValue">20</span>%</label>
                        <input type="range" id="lineThreshold" min="10" max="80" value="20" oninput="updateThreshold()">
                        <div class="value-display">Min % szeroko≈õci/wysoko≈õci</div>
                    </div>

                    <button class="btn-control" onclick="recalculateAlignment()">üîÑ Przelicz Alignment</button>
                    <button class="btn-control" onclick="toggleFrameVisualization()" id="frameVisBtn">üëÅÔ∏è Poka≈º Ramki</button>
                    
                    <div class="alignment-info">
                        <strong>Alignment Info:</strong>
                        <div>Offset X: <span id="offsetX">-</span>px</div>
                        <div>Offset Y: <span id="offsetY">-</span>px</div>
                        <div>Scale X: <span id="scaleX">-</span></div>
                        <div>Scale Y: <span id="scaleY">-</span></div>
                    </div>

                    <div class="alignment-info" style="background: #d1ecf1; margin-top: 10px;">
                        <strong>üîç Debug Info:</strong>
                        <div>H-Lines: <span id="hLinesCount">-</span></div>
                        <div>V-Lines: <span id="vLinesCount">-</span></div>
                        <div>OLD Frame: <span id="oldFrameInfo">-</span></div>
                        <div>NEW Frame: <span id="newFrameInfo">-</span></div>
                    </div>

                    <hr style="margin: 20px 0;">
                    <h3>üéÆ Controls</h3>

                    <div class="control-group">
                        <label>Toggle Speed: <span id="toggleSpeedValue">1000</span>ms</label>
                        <input type="range" id="toggleSpeed" min="200" max="3000" value="1000" step="100" oninput="updateToggleSpeed()">
                    </div>

                    <button class="btn-control" onclick="toggleAuto()" id="autoBtn">‚ñ∂Ô∏è Auto Toggle</button>
                    
                    <button class="btn-control" onclick="manualToggle()">üîÑ Manual Toggle</button>

                    <div class="control-group">
                        <label>Zoom: <span id="zoomValue">100</span>%</label>
                        <input type="range" id="zoomSlider" min="50" max="200" value="100" oninput="updateZoom()">
                    </div>

                    <button class="btn-control" onclick="rotateMap(90)">‚Üª Obr√≥ƒá 90¬∞</button>
                    <button class="btn-control" onclick="resetView()">üè† Reset View</button>
                </div>

                <div class="viewer-area">
                    <div class="viewer-header">
                        <div class="page-nav">
                            <button onclick="prevPage()">‚óÄ Poprzednia</button>
                            <div id="pageInfo" style="padding: 8px 16px; background: white; border-radius: 5px; font-weight: bold;">
                                Strona 1 z 1
                            </div>
                            <button onclick="nextPage()">Nastƒôpna ‚ñ∂</button>
                        </div>
                        <button class="btn btn-primary" onclick="resetAndUpload()" style="padding: 8px 20px;">
                            üîÑ Nowe Por√≥wnanie
                        </button>
                    </div>

                    <div class="viewer-wrapper" id="viewerWrapper">
                        <div class="canvas-container" id="oldCanvasContainer" style="visibility: visible;">
                            <canvas id="oldCanvas"></canvas>
                            <div class="label old">OLD</div>
                        </div>
                        <div class="canvas-container" id="newCanvasContainer" style="visibility: hidden;">
                            <canvas id="newCanvas"></canvas>
                            <div class="label new">NEW</div>
                        </div>
                    </div>
                </div>
            </div>
        </div>
    </div>

    <script>
        pdfjsLib.GlobalWorkerOptions.workerSrc = 'https://cdnjs.cloudflare.com/ajax/libs/pdf.js/3.11.174/pdf.worker.min.js';

        let oldFile = null;
        let newFile = null;
        let oldDoc = null;
        let newDoc = null;
        let currentPage = 1;
        let totalPages = 1;
        let showingOld = true;
        let autoToggleInterval = null;
        let currentZoom = 1.0;
        let currentRotation = 0;
        let alignmentData = null;
        let showFrames = false;

        // Pan variables
        let isPanning = false;
        let panStartX = 0;
        let panStartY = 0;
        let panOffsetX = 0;
        let panOffsetY = 0;
        let scale = 1.0;  // Zoom scale

        // Frame detection parameters - optimized for SOLID frames (v1.9)
        let edgeThreshold = 12;
        let gapTolerance = 5;  // Zmniejszone z 10 na 5 - preferuje solidne ramki
        let lineThreshold = 0.20;

        // Debug info
        let debugInfo = {
            oldHLines: 0,
            oldVLines: 0,
            newHLines: 0,
            newVLines: 0,
            oldFrame: null,
            newFrame: null
        };

        // Setup drag and drop
        ['dropZoneOld', 'dropZoneNew'].forEach(id => {
            const zone = document.getElementById(id);
            zone.addEventListener('dragover', (e) => {
                e.preventDefault();
                zone.classList.add('drag-over');
            });
            zone.addEventListener('dragleave', () => {
                zone.classList.remove('drag-over');
            });
            zone.addEventListener('drop', async (e) => {
                e.preventDefault();
                zone.classList.remove('drag-over');
                const files = Array.from(e.dataTransfer.files).filter(f => f.name.endsWith('.pdf'));
                if (files.length > 0) {
                    if (id === 'dropZoneOld') {
                        await loadOldFile(files[0]);
                    } else {
                        await loadNewFile(files[0]);
                    }
                }
            });
        });

        document.getElementById('oldFileInput').addEventListener('change', async (e) => {
            if (e.target.files.length > 0) {
                await loadOldFile(e.target.files[0]);
            }
        });

        document.getElementById('newFileInput').addEventListener('change', async (e) => {
            if (e.target.files.length > 0) {
                await loadNewFile(e.target.files[0]);
            }
        });

        async function loadOldFile(file) {
            oldFile = file;
            document.getElementById('oldFileName').textContent = `‚úÖ ${file.name}`;
            checkBothFilesLoaded();
        }

        async function loadNewFile(file) {
            newFile = file;
            document.getElementById('newFileName').textContent = `‚úÖ ${file.name}`;
            checkBothFilesLoaded();
        }

        function checkBothFilesLoaded() {
            if (oldFile && newFile) {
                document.getElementById('startButtonContainer').style.display = 'block';
            }
        }

        function updateProgress(percent, text) {
            document.getElementById('progressBar').style.width = percent + '%';
            document.getElementById('progressText').textContent = percent + '%';
            document.getElementById('loadingText').textContent = text;
        }

        async function startComparison() {
            document.getElementById('uploadSection').style.display = 'none';
            document.getElementById('loading').style.display = 'block';

            try {
                // Load OLD PDF
                updateProgress(10, '≈Åadowanie OLD PDF...');
                const oldBuffer = await oldFile.arrayBuffer();
                oldDoc = await pdfjsLib.getDocument({data: oldBuffer}).promise;

                // Load NEW PDF
                updateProgress(30, '≈Åadowanie NEW PDF...');
                const newBuffer = await newFile.arrayBuffer();
                newDoc = await pdfjsLib.getDocument({data: newBuffer}).promise;

                totalPages = Math.max(oldDoc.numPages, newDoc.numPages);

                // Calculate alignment
                updateProgress(50, 'Wykrywanie ramek i obliczanie alignment...');
                await calculateAlignment();

                updateProgress(90, 'Renderowanie...');
                document.getElementById('loading').style.display = 'none';
                document.getElementById('comparisonSection').style.display = 'block';

                await renderCurrentPage();
                
                // Start auto toggle
                setTimeout(() => toggleAuto(), 500);
                
                // Auto-show frames so user can see detection results
                setTimeout(() => {
                    showFrames = true;
                    document.getElementById('frameVisBtn').textContent = 'üëÅÔ∏è Ukryj Ramki';
                    document.getElementById('frameVisBtn').classList.add('active');
                    drawFrameOverlays();
                }, 1000);
            } catch (error) {
                console.error('Error:', error);
                alert('B≈ÇƒÖd podczas ≈Çadowania plik√≥w: ' + error.message);
            }
        }

        async function calculateAlignment() {
            try {
                const scale = 2.0;

                // Render OLD page
                const oldPage = await oldDoc.getPage(currentPage);
                const oldViewport = oldPage.getViewport({scale: scale});
                const oldCanvas = document.createElement('canvas');
                oldCanvas.width = oldViewport.width;
                oldCanvas.height = oldViewport.height;
                const oldCtx = oldCanvas.getContext('2d');
                await oldPage.render({canvasContext: oldCtx, viewport: oldViewport}).promise;

                // Render NEW page
                const newPage = await newDoc.getPage(currentPage);
                const newViewport = newPage.getViewport({scale: scale});
                const newCanvas = document.createElement('canvas');
                newCanvas.width = newViewport.width;
                newCanvas.height = newViewport.height;
                const newCtx = newCanvas.getContext('2d');
                await newPage.render({canvasContext: newCtx, viewport: newViewport}).promise;

                // Detect frames
                const oldFrame = detectFrame(oldCtx, oldCanvas.width, oldCanvas.height);
                const newFrame = detectFrame(newCtx, newCanvas.width, newCanvas.height);

                // Save debug info
                debugInfo = {
                    oldHLines: oldFrame.debugInfo ? oldFrame.debugInfo.hLinesCount : 0,
                    oldVLines: oldFrame.debugInfo ? oldFrame.debugInfo.vLinesCount : 0,
                    newHLines: newFrame.debugInfo ? newFrame.debugInfo.hLinesCount : 0,
                    newVLines: newFrame.debugInfo ? newFrame.debugInfo.vLinesCount : 0,
                    oldFrame: oldFrame,
                    newFrame: newFrame
                };

                console.log('Frame Detection Results:', debugInfo);

                // === PROSTE OBLICZENIA DLA drawImage() ===
                const detectionScale = 2.0;
                const renderScale = 3.0;
                const ratio = renderScale / detectionScale; // 1.5
                
                // Przelicz wsp√≥≈Çrzƒôdne ramek na skalƒô renderowania  
                const oldF = {
                    x: oldFrame.x * ratio,
                    y: oldFrame.y * ratio,
                    w: oldFrame.width * ratio,
                    h: oldFrame.height * ratio
                };
                
                const newF = {
                    x: newFrame.x * ratio,
                    y: newFrame.y * ratio,
                    w: newFrame.width * ratio,
                    h: newFrame.height * ratio
                };
                
                // Oblicz scale ≈ºeby OLD frame mia≈Ç rozmiar NEW frame
                const scaleX = newF.w / oldF.w;
                const scaleY = newF.h / oldF.h;
                
                // Oblicz offset ≈ºeby ramka OLD by≈Ça w miejscu ramki NEW
                // Po scale ramka OLD bƒôdzie w (oldF.x * scaleX, oldF.y * scaleY)
                // Chcemy ≈ºeby by≈Ça w (newF.x, newF.y)
                const offsetX = newF.x - oldF.x * scaleX;
                const offsetY = newF.y - oldF.y * scaleY;
                
                alignmentData = {
                    scaleX: scaleX,
                    scaleY: scaleY,
                    shiftX: offsetX,
                    shiftY: offsetY,
                    oldFrame: oldFrame,
                    newFrame: newFrame,
                    oldF: oldF,
                    newF: newF
                };
                
                console.log('‚ïî‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïó');
                console.log('‚ïë    drawImage() PARAMETRY              ‚ïë');
                console.log('‚ïö‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïù');
                console.log('OLD frame (display scale):', oldF);
                console.log('NEW frame (display scale):', newF);
                console.log('Scale:', { X: scaleX.toFixed(4), Y: scaleY.toFixed(4) });
                console.log('Offset:', { X: offsetX.toFixed(2), Y: offsetY.toFixed(2) });
                console.log('');
                console.log('VERIFICATION:');
                console.log('  OLD frame left after:', (oldF.x * scaleX + offsetX).toFixed(2), '‚Üí', newF.x.toFixed(2));
                console.log('  OLD frame top after:', (oldF.y * scaleY + offsetY).toFixed(2), '‚Üí', newF.y.toFixed(2));
                console.log('  OLD frame width after:', (oldF.w * scaleX).toFixed(2), '‚Üí', newF.w.toFixed(2));
                console.log('  OLD frame height after:', (oldF.h * scaleY).toFixed(2), '‚Üí', newF.h.toFixed(2));
                console.log('‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê');

                updateAlignmentInfo();
                updateDebugInfo();

            } catch (error) {
                console.error('Alignment calculation error:', error);
                alignmentData = {
                    shiftX: 0,
                    shiftY: 0,
                    scaleX: 1,
                    scaleY: 1
                };
            }
        }

        // ============================================
        // HELPER FUNCTIONS FOR ADVANCED FRAME DETECTION
        // ============================================
        
        function extractLineColor(data, width, height, line, isHorizontal) {
            // Pobierz kolory pikseli wzd≈Çu≈º linii
            const colors = [];
            const samples = 50; // Sample 50 punkt√≥w wzd≈Çu≈º linii
            
            if (isHorizontal) {
                const y = Math.round(line.y);
                const step = Math.max(1, Math.floor((line.x2 - line.x1) / samples));
                for (let x = line.x1; x <= line.x2; x += step) {
                    const idx = (y * width + Math.round(x)) * 4;
                    if (idx >= 0 && idx < data.length - 3) {
                        colors.push({
                            r: data[idx],
                            g: data[idx + 1],
                            b: data[idx + 2]
                        });
                    }
                }
            } else {
                const x = Math.round(line.x);
                const step = Math.max(1, Math.floor((line.y2 - line.y1) / samples));
                for (let y = line.y1; y <= line.y2; y += step) {
                    const idx = (Math.round(y) * width + x) * 4;
                    if (idx >= 0 && idx < data.length - 3) {
                        colors.push({
                            r: data[idx],
                            g: data[idx + 1],
                            b: data[idx + 2]
                        });
                    }
                }
            }
            
            if (colors.length === 0) return { r: 0, g: 0, b: 0 };
            
            // Oblicz ≈õredni kolor (mediana by≈Çaby lepsza, ale to wystarczy)
            const avgR = colors.reduce((sum, c) => sum + c.r, 0) / colors.length;
            const avgG = colors.reduce((sum, c) => sum + c.g, 0) / colors.length;
            const avgB = colors.reduce((sum, c) => sum + c.b, 0) / colors.length;
            
            return { r: avgR, g: avgG, b: avgB };
        }
        
        function colorDistance(c1, c2) {
            // Euclidean distance w przestrzeni RGB
            const dr = c1.r - c2.r;
            const dg = c1.g - c2.g;
            const db = c1.b - c2.b;
            return Math.sqrt(dr*dr + dg*dg + db*db);
        }
        
        function colorHarmony(color) {
            // Sprawd≈∫ "charakter" koloru przez odchylenie standardowe RGB
            // Kolory neutralne (czarny, szary, bia≈Çy): stdDev ‚âà 0
            // Kolory nasycone (≈º√≥≈Çty, cyjan, czerwony): stdDev > 50
            const mean = (color.r + color.g + color.b) / 3;
            const variance = ((color.r - mean)**2 + (color.g - mean)**2 + (color.b - mean)**2) / 3;
            return Math.sqrt(variance); // zwraca odchylenie standardowe
        }
        
        function colorsHaveCompatibleHue(colors) {
            // Sprawd≈∫ czy wszystkie kolory majƒÖ podobny "charakter"
            // (neutralne vs nasycone)
            const harmonies = colors.map(c => colorHarmony(c));
            const avgHarmony = harmonies.reduce((a, b) => a + b, 0) / harmonies.length;
            
            // Sprawd≈∫ czy kt√≥ry≈õ kolor drastycznie odstaje charakterem
            for (const h of harmonies) {
                const diff = Math.abs(h - avgHarmony);
                // Je≈õli jeden kolor ma odchylenie 80 (≈º√≥≈Çty) a reszta 5 (szary)
                // to diff bƒôdzie ~75 - odrzuƒá!
                if (diff > 40) {
                    return false;
                }
            }
            return true;
        }
        
        function gaussianBlur(data, width, height) {
            const blurred = new Uint8ClampedArray(data.length);
            const kernel = [1, 2, 1, 2, 4, 2, 1, 2, 1];
            const kernelSum = 16;
            
            for (let y = 1; y < height - 1; y++) {
                for (let x = 1; x < width - 1; x++) {
                    for (let c = 0; c < 3; c++) {
                        let sum = 0;
                        let ki = 0;
                        for (let dy = -1; dy <= 1; dy++) {
                            for (let dx = -1; dx <= 1; dx++) {
                                const i = ((y + dy) * width + (x + dx)) * 4 + c;
                                sum += data[i] * kernel[ki++];
                            }
                        }
                        blurred[(y * width + x) * 4 + c] = sum / kernelSum;
                    }
                    blurred[(y * width + x) * 4 + 3] = 255; // Alpha
                }
            }
            return blurred;
        }
        
        // === NOWA FUNKCJA v3.10: Sharpening dla cienkich linii ===
        function sharpenImage(data, width, height) {
            const sharpened = new Uint8ClampedArray(data.length);
            // Kernel unsharp masking: zwiƒôksza kontrast na krawƒôdziach
            const kernel = [0, -1, 0, -1, 5, -1, 0, -1, 0];
            
            for (let y = 1; y < height - 1; y++) {
                for (let x = 1; x < width - 1; x++) {
                    for (let c = 0; c < 3; c++) {
                        let sum = 0;
                        let ki = 0;
                        for (let dy = -1; dy <= 1; dy++) {
                            for (let dx = -1; dx <= 1; dx++) {
                                const i = ((y + dy) * width + (x + dx)) * 4 + c;
                                sum += data[i] * kernel[ki++];
                            }
                        }
                        sharpened[(y * width + x) * 4 + c] = Math.max(0, Math.min(255, sum));
                    }
                    sharpened[(y * width + x) * 4 + 3] = 255; // Alpha
                }
            }
            return sharpened;
        }
        
        // === NOWA FUNKCJA v3.10: Contrast-based edge detection dla cienkich linii ===
        // Wykrywa piksele kt√≥re sƒÖ ciemniejsze od otoczenia (= potencjalne linie)
        function detectThinLines(data, width, height, threshold = 20) {
            const edges = new Float32Array(width * height);
            const strength = new Float32Array(width * height);
            
            for (let y = 2; y < height - 2; y++) {
                for (let x = 2; x < width - 2; x++) {
                    const idx = y * width + x;
                    
                    // Pobierz brightness obecnego piksela
                    const i = idx * 4;
                    const centerBrightness = (data[i] + data[i+1] + data[i+2]) / 3;
                    
                    // Pobierz ≈õredniƒÖ brightness z otoczenia (5x5, pomijajƒÖc ≈õrodek)
                    let surroundSum = 0;
                    let surroundCount = 0;
                    
                    for (let dy = -2; dy <= 2; dy++) {
                        for (let dx = -2; dx <= 2; dx++) {
                            if (dx === 0 && dy === 0) continue; // pomijamy ≈õrodek
                            const si = ((y + dy) * width + (x + dx)) * 4;
                            surroundSum += (data[si] + data[si+1] + data[si+2]) / 3;
                            surroundCount++;
                        }
                    }
                    
                    const surroundAvg = surroundSum / surroundCount;
                    
                    // Kontrast = r√≥≈ºnica miƒôdzy otoczeniem a ≈õrodkiem
                    // Dodatni kontrast = piksel CIEMNIEJSZY od otoczenia (linia!)
                    const contrast = surroundAvg - centerBrightness;
                    
                    if (contrast > threshold) {
                        edges[idx] = 1;
                        strength[idx] = contrast;
                    }
                }
            }
            
            return { edges, strength };
        }
        
        // === NOWA FUNKCJA v3.10: Oblicz dynamicznƒÖ grubo≈õƒá linii ===
        function calculateLineThickness(hLine, vLine, edges, width, height) {
            // Sprawd≈∫ grubo≈õƒá linii poziomej w okolicy przeciƒôcia
            let hThickness = 0;
            let vThickness = 0;
            
            // Dla linii poziomej: ile pikseli w pionie jest wype≈Çnionych wok√≥≈Ç y?
            const checkX = Math.floor((hLine.x1 + hLine.x2) / 2); // ≈õrodek linii
            const checkY = hLine.y;
            
            for (let dy = -5; dy <= 5; dy++) {
                const idx = (checkY + dy) * width + checkX;
                if (edges[idx] === 1) {
                    hThickness++;
                }
            }
            
            // Dla linii pionowej: ile pikseli w poziomie jest wype≈Çnionych wok√≥≈Ç x?
            const checkY2 = Math.floor((vLine.y1 + vLine.y2) / 2); // ≈õrodek linii
            const checkX2 = vLine.x;
            
            for (let dx = -5; dx <= 5; dx++) {
                const idx = checkY2 * width + (checkX2 + dx);
                if (edges[idx] === 1) {
                    vThickness++;
                }
            }
            
            // Zwr√≥ƒá ≈õredniƒÖ grubo≈õƒá
            return (hThickness + vThickness) / 2;
        }
        
        function findRobustLines(edges, strength, width, height, isHorizontal) {
            const lines = [];
            const size = isHorizontal ? height : width;
            const perpSize = isHorizontal ? width : height;
            
            for (let pos = 0; pos < size; pos++) {
                let lineSegments = [];
                let currentSegment = null;
                
                for (let perp = 0; perp < perpSize; perp++) {
                    const idx = isHorizontal ? (pos * width + perp) : (perp * width + pos);
                    
                    if (edges[idx] === 1) {
                        if (!currentSegment) {
                            currentSegment = {
                                start: perp,
                                end: perp,
                                totalStrength: strength[idx],
                                count: 1
                            };
                        } else {
                            currentSegment.end = perp;
                            currentSegment.totalStrength += strength[idx];
                            currentSegment.count++;
                        }
                    } else {
                        if (currentSegment) {
                            const length = currentSegment.end - currentSegment.start + 1;
                            if (length > gapTolerance) {
                                lineSegments.push(currentSegment);
                            }
                            currentSegment = null;
                        }
                    }
                }
                
                if (currentSegment) {
                    const length = currentSegment.end - currentSegment.start + 1;
                    if (length > gapTolerance) {
                        lineSegments.push(currentSegment);
                    }
                }
                
                // ≈ÅƒÖcz bliskie segmenty
                const merged = mergeNearSegments(lineSegments, gapTolerance);
                
                // Stw√≥rz linie ze scalonych segment√≥w
                for (const seg of merged) {
                    const length = seg.end - seg.start + 1;
                    const avgStrength = seg.totalStrength / seg.count;
                    
                    if (length >= perpSize * lineThreshold) {
                        const coverage = length / perpSize;
                        const continuity = seg.solidLength / length;
                        
                        // Scoring: PRIORYTET dla ciƒÖg≈Çych (solid) linii
                        // Continuity^3 mocno nagradza linie bez przerw
                        const score = coverage * Math.pow(continuity, 3) * (avgStrength / 50);
                        
                        const line = isHorizontal ? 
                            { y: pos, x1: seg.start, x2: seg.end, length, continuity, avgStrength, score, solidLength: seg.solidLength } :
                            { x: pos, y1: seg.start, y2: seg.end, length, continuity, avgStrength, score, solidLength: seg.solidLength };
                        
                        lines.push(line);
                    }
                }
            }
            
            return lines;
        }
        
        function mergeNearSegments(segments, maxGap) {
            if (segments.length === 0) return [];
            
            segments.sort((a, b) => a.start - b.start);
            const merged = [];
            let current = { ...segments[0], solidLength: segments[0].end - segments[0].start + 1 };
            
            for (let i = 1; i < segments.length; i++) {
                const seg = segments[i];
                const gap = seg.start - current.end;
                
                if (gap <= maxGap) {
                    current.end = seg.end;
                    current.totalStrength += seg.totalStrength;
                    current.count += seg.count;
                    current.solidLength += seg.end - seg.start + 1;
                } else {
                    merged.push(current);
                    current = { ...seg, solidLength: seg.end - seg.start + 1 };
                }
            }
            merged.push(current);
            
            return merged;
        }
        
        function groupCloseLines(lines, isHorizontal, dimension) {
            if (lines.length === 0) return [];
            
            lines.sort((a, b) => {
                const posA = isHorizontal ? a.y : a.x;
                const posB = isHorizontal ? b.y : b.x;
                return posA - posB;
            });
            
            const groups = [];
            const groupThreshold = Math.max(3, dimension * 0.005);
            
            let currentGroup = [lines[0]];
            
            for (let i = 1; i < lines.length; i++) {
                const prevPos = isHorizontal ? currentGroup[currentGroup.length - 1].y : currentGroup[currentGroup.length - 1].x;
                const currPos = isHorizontal ? lines[i].y : lines[i].x;
                
                if (currPos - prevPos <= groupThreshold) {
                    currentGroup.push(lines[i]);
                } else {
                    const best = currentGroup.reduce((a, b) => a.score > b.score ? a : b);
                    groups.push(best);
                    currentGroup = [lines[i]];
                }
            }
            
            if (currentGroup.length > 0) {
                const best = currentGroup.reduce((a, b) => a.score > b.score ? a : b);
                groups.push(best);
            }
            
            return groups;
        }
        
        // === CORNER DETECTION: Znajd≈∫ wszystkie naro≈ºniki (przeciƒôcia H i V linii) ===
        function detectCorners(hLines, vLines, cornerTolerance = 10) {
            const corners = [];
            const maxGap = 3;  // v3.16: Edge Consistency Filter - 3px gap tolerance (inherited from v3.15)
            
            for (const hLine of hLines) {
                for (const vLine of vLines) {
                    // Sprawd≈∫ czy linie siƒô przecinajƒÖ
                    // V-line musi byƒá w zakresie X linii H
                    const vIntersectsH = vLine.x >= hLine.x1 - cornerTolerance && 
                                         vLine.x <= hLine.x2 + cornerTolerance;
                    
                    // H-line musi byƒá w zakresie Y linii V
                    const hIntersectsV = hLine.y >= vLine.y1 - cornerTolerance && 
                                         hLine.y <= vLine.y2 + cornerTolerance;
                    
                    if (vIntersectsH && hIntersectsV) {
                        // Oblicz DOK≈ÅADNY GAP SIZE
                        // Gap w H-line: jak daleko vLine.x jest od ko≈Ñc√≥w H-line
                        const gapHLeft = Math.max(0, hLine.x1 - vLine.x);  // gap z lewej strony
                        const gapHRight = Math.max(0, vLine.x - hLine.x2); // gap z prawej strony
                        const gapH = Math.min(gapHLeft, gapHRight);  // we≈∫ mniejszy gap
                        
                        // Gap w V-line: jak daleko hLine.y jest od ko≈Ñc√≥w V-line
                        const gapVTop = Math.max(0, vLine.y1 - hLine.y);    // gap z g√≥ry
                        const gapVBottom = Math.max(0, hLine.y - vLine.y2); // gap z do≈Çu
                        const gapV = Math.min(gapVTop, gapVBottom);  // we≈∫ mniejszy gap
                        
                        // MAKSYMALNY gap z obu linii
                        const maxGapAtCorner = Math.max(gapH, gapV);
                        
                        // ODRZUƒÜ naro≈ºnik je≈õli gap jest za du≈ºy!
                        if (maxGapAtCorner > maxGap) {
                            continue;  // Skip ten naro≈ºnik
                        }
                        
                        // Oblicz CORNER QUALITY (0.0 = s≈Çaby, 1.0 = doskona≈Çy)
                        // Im mniejszy gap, tym lepszy quality
                        const gapPenalty = Math.max(0, 1 - (maxGapAtCorner / maxGap));
                        const continuityScore = (hLine.continuity + vLine.continuity) / 2;
                        const strengthScore = Math.min(1, (hLine.avgStrength + vLine.avgStrength) / 100);
                        
                        const cornerQuality = gapPenalty * continuityScore * strengthScore;
                        
                        // To jest dobry naro≈ºnik!
                        corners.push({
                            x: vLine.x,
                            y: hLine.y,
                            hLine: hLine,
                            vLine: vLine,
                            strength: (hLine.avgStrength + vLine.avgStrength) / 2,
                            hContinuity: hLine.continuity,
                            vContinuity: vLine.continuity,
                            avgContinuity: (hLine.continuity + vLine.continuity) / 2,
                            gap: maxGapAtCorner,          // NEW: gap size
                            gapH: gapH,                   // NEW: gap w H-line
                            gapV: gapV,                   // NEW: gap w V-line
                            quality: cornerQuality        // NEW: corner quality score
                        });
                    }
                }
            }
            
            return corners;
        }
        
        // === ZNAJD≈π RAMKƒò Z 4 NARO≈ªNIK√ìW ===
        function findFrameFromCorners(corners, width, height, imageData, edges) {
            if (corners.length < 4) {
                console.log(`‚ö†Ô∏è Not enough corners detected: ${corners.length}`);
                return null;
            }
            
            console.log(`üéØ Detected ${corners.length} corners`);
            
            // Podziel mapƒô na 4 ƒáwiartki
            const midX = width / 2;
            const midY = height / 2;
            const margin = Math.min(width, height) * 0.05; // 5% margines
            const edgeMargin = Math.max(10, Math.min(width, height) * 0.02); // 10px minimum lub 2% od brzegu
            
            console.log(`Edge margin: ${Math.round(edgeMargin)}px (corners within this distance from edge are rejected)`);
            
            // Ekstrakcja kolor√≥w dla linii w naro≈ºnikach
            corners.forEach(corner => {
                corner.hLine.color = corner.hLine.color || extractLineColor(imageData, width, height, corner.hLine, true);
                corner.vLine.color = corner.vLine.color || extractLineColor(imageData, width, height, corner.vLine, false);
            });
            
            // === ƒÜWIARTKA 1: TOP-LEFT ===
            const topLeftCandidates = corners
                .filter(c => c.x < midX && c.y < midY)  // g√≥rna lewa ƒáwiartka
                .filter(c => c.x > edgeMargin && c.y > edgeMargin)  // NIE przy brzegu
                .sort((a, b) => {
                    // KLUCZOWA ZMIANA v3.11: Dla rog√≥w z gap ‚â§3px u≈ºywamy SUMY, dla wiƒôkszych MAX
                    // SUMA (x + y) patrzy na OBIE wsp√≥≈Çrzƒôdne jednocze≈õnie!
                    // MAX wybiera najbli≈ºszy do JEDNEJ krawƒôdzi, ignorujƒÖc drugƒÖ
                    
                    // Dla rog√≥w z ma≈Çym gapem: minimalizuj SUMƒò odleg≈Ço≈õci (x + y)
                    // Dla rog√≥w z du≈ºym gapem: minimalizuj MAX odleg≈Ço≈õci
                    const aHasSmallGap = a.gap <= 3;
                    const bHasSmallGap = b.gap <= 3;
                    
                    const aDist = aHasSmallGap ? (a.x + a.y) : Math.max(a.x, a.y);
                    const bDist = bHasSmallGap ? (b.x + b.y) : Math.max(b.x, b.y);
                    
                    // Quality bonus
                    const aQualityBonus = a.quality * 5;
                    const bQualityBonus = b.quality * 5;
                    
                    // Gap bonus - wiƒôkszy dla rog√≥w z bardzo ma≈Çym gapem
                    const aGapBonus = (a.gap <= 3) ? 30 : 0;  // zwiƒôkszone z 20 do 30!
                    const bGapBonus = (b.gap <= 3) ? 30 : 0;
                    
                    // Im mniejszy dist tym bli≈ºej rogu!
                    return (aDist - aQualityBonus - aGapBonus) - (bDist - bQualityBonus - bGapBonus);
                });
            
            // === ƒÜWIARTKA 2: TOP-RIGHT ===
            const topRightCandidates = corners
                .filter(c => c.x > midX && c.y < midY)  // g√≥rna prawa ƒáwiartka
                .filter(c => c.x < width - edgeMargin && c.y > edgeMargin)
                .sort((a, b) => {
                    // KLUCZOWA ZMIANA v3.11: SUMA dla rog√≥w z gap ‚â§3px
                    const aHasSmallGap = a.gap <= 3;
                    const bHasSmallGap = b.gap <= 3;
                    
                    // Dla TOP-RIGHT minimalizujemy: (width - x) + y
                    const aDist = aHasSmallGap ? ((width - a.x) + a.y) : Math.max(width - a.x, a.y);
                    const bDist = bHasSmallGap ? ((width - b.x) + b.y) : Math.max(width - b.x, b.y);
                    
                    const aQualityBonus = a.quality * 5;
                    const bQualityBonus = b.quality * 5;
                    const aGapBonus = (a.gap <= 3) ? 30 : 0;
                    const bGapBonus = (b.gap <= 3) ? 30 : 0;
                    return (aDist - aQualityBonus - aGapBonus) - (bDist - bQualityBonus - bGapBonus);
                });
            
            // === ƒÜWIARTKA 3: BOTTOM-LEFT ===
            const bottomLeftCandidates = corners
                .filter(c => c.x < midX && c.y > midY)  // dolna lewa ƒáwiartka
                .filter(c => c.x > edgeMargin && c.y < height - edgeMargin)
                .sort((a, b) => {
                    // KLUCZOWA ZMIANA v3.11: SUMA dla rog√≥w z gap ‚â§3px
                    const aHasSmallGap = a.gap <= 3;
                    const bHasSmallGap = b.gap <= 3;
                    
                    // Dla BOTTOM-LEFT minimalizujemy: x + (height - y)
                    const aDist = aHasSmallGap ? (a.x + (height - a.y)) : Math.max(a.x, height - a.y);
                    const bDist = bHasSmallGap ? (b.x + (height - b.y)) : Math.max(b.x, height - b.y);
                    
                    const aQualityBonus = a.quality * 5;
                    const bQualityBonus = b.quality * 5;
                    const aGapBonus = (a.gap <= 3) ? 30 : 0;
                    const bGapBonus = (b.gap <= 3) ? 30 : 0;
                    return (aDist - aQualityBonus - aGapBonus) - (bDist - bQualityBonus - bGapBonus);
                });
            
            // === ƒÜWIARTKA 4: BOTTOM-RIGHT ===
            const bottomRightCandidates = corners
                .filter(c => c.x > midX && c.y > midY)  // dolna prawa ƒáwiartka
                .filter(c => c.x < width - edgeMargin && c.y < height - edgeMargin)
                .sort((a, b) => {
                    // KLUCZOWA ZMIANA v3.11: SUMA dla rog√≥w z gap ‚â§3px
                    const aHasSmallGap = a.gap <= 3;
                    const bHasSmallGap = b.gap <= 3;
                    
                    // Dla BOTTOM-RIGHT minimalizujemy: (width - x) + (height - y)
                    const aDist = aHasSmallGap ? ((width - a.x) + (height - a.y)) : Math.max(width - a.x, height - a.y);
                    const bDist = bHasSmallGap ? ((width - b.x) + (height - b.y)) : Math.max(width - b.x, height - b.y);
                    
                    const aQualityBonus = a.quality * 5;
                    const bQualityBonus = b.quality * 5;
                    const aGapBonus = (a.gap <= 3) ? 30 : 0;
                    const bGapBonus = (b.gap <= 3) ? 30 : 0;
                    return (aDist - aQualityBonus - aGapBonus) - (bDist - bQualityBonus - bGapBonus);
                });
            
            console.log(`Quadrant corners: TL=${topLeftCandidates.length}, TR=${topRightCandidates.length}, BL=${bottomLeftCandidates.length}, BR=${bottomRightCandidates.length}`);
            
            // === DEBUG: Poka≈º TOP 3 kandydat√≥w z ka≈ºdej ƒáwiartki ===
            console.log(`\nüîç TOP-LEFT candidates (top 3):`);
            topLeftCandidates.slice(0, 3).forEach((c, i) => {
                const hasSmallGap = c.gap <= 3;
                const dist = hasSmallGap ? (c.x + c.y) : Math.max(c.x, c.y);
                const distType = hasSmallGap ? 'SUM' : 'MAX';
                const qualBonus = c.quality * 5;
                const gapBonus = (c.gap <= 3) ? 30 : 0;
                const finalScore = dist - qualBonus - gapBonus;
                console.log(`   ${i+1}. pos=(${Math.round(c.x)}, ${Math.round(c.y)}) gap=${c.gap.toFixed(1)}px quality=${c.quality.toFixed(2)} ‚Üí ${distType}=${dist.toFixed(1)} - qual=${qualBonus.toFixed(1)} - gap=${gapBonus.toFixed(1)} = ${finalScore.toFixed(1)}`);
            });
            
            console.log(`\nüîç TOP-RIGHT candidates (top 3):`);
            topRightCandidates.slice(0, 3).forEach((c, i) => {
                const hasSmallGap = c.gap <= 3;
                const dist = hasSmallGap ? ((width - c.x) + c.y) : Math.max(width - c.x, c.y);
                const distType = hasSmallGap ? 'SUM' : 'MAX';
                const qualBonus = c.quality * 5;
                const gapBonus = (c.gap <= 3) ? 30 : 0;
                const finalScore = dist - qualBonus - gapBonus;
                console.log(`   ${i+1}. pos=(${Math.round(c.x)}, ${Math.round(c.y)}) gap=${c.gap.toFixed(1)}px quality=${c.quality.toFixed(2)} ‚Üí ${distType}=${dist.toFixed(1)} - qual=${qualBonus.toFixed(1)} - gap=${gapBonus.toFixed(1)} = ${finalScore.toFixed(1)}`);
            });
            
            console.log(`\nüîç BOTTOM-LEFT candidates (top 3):`);
            bottomLeftCandidates.slice(0, 3).forEach((c, i) => {
                const hasSmallGap = c.gap <= 3;
                const dist = hasSmallGap ? (c.x + (height - c.y)) : Math.max(c.x, height - c.y);
                const distType = hasSmallGap ? 'SUM' : 'MAX';
                const qualBonus = c.quality * 5;
                const gapBonus = (c.gap <= 3) ? 30 : 0;
                const finalScore = dist - qualBonus - gapBonus;
                console.log(`   ${i+1}. pos=(${Math.round(c.x)}, ${Math.round(c.y)}) gap=${c.gap.toFixed(1)}px quality=${c.quality.toFixed(2)} ‚Üí ${distType}=${dist.toFixed(1)} - qual=${qualBonus.toFixed(1)} - gap=${gapBonus.toFixed(1)} = ${finalScore.toFixed(1)}`);
            });
            
            console.log(`\nüîç BOTTOM-RIGHT candidates (top 3):`);
            bottomRightCandidates.slice(0, 3).forEach((c, i) => {
                const hasSmallGap = c.gap <= 3;
                const dist = hasSmallGap ? ((width - c.x) + (height - c.y)) : Math.max(width - c.x, height - c.y);
                const distType = hasSmallGap ? 'SUM' : 'MAX';
                const qualBonus = c.quality * 5;
                const gapBonus = (c.gap <= 3) ? 30 : 0;
                const finalScore = dist - qualBonus - gapBonus;
                console.log(`   ${i+1}. pos=(${Math.round(c.x)}, ${Math.round(c.y)}) gap=${c.gap.toFixed(1)}px quality=${c.quality.toFixed(2)} ‚Üí ${distType}=${dist.toFixed(1)} - qual=${qualBonus.toFixed(1)} - gap=${gapBonus.toFixed(1)} = ${finalScore.toFixed(1)}`);
            });
            console.log('');  // Pusty wiersz dla czytelno≈õci
            
            if (topLeftCandidates.length === 0 || topRightCandidates.length === 0 || 
                bottomLeftCandidates.length === 0 || bottomRightCandidates.length === 0) {
                console.log('‚ùå Not enough corners in all quadrants');
                return null;
            }
            
            // NOWE v3.11: Filtruj rogi na tej samej linii - zostaw tylko najbardziej zewnƒôtrzne!
            function filterDominatedCorners(corners, quadrant) {
                // SIMPLIFIED v3.14: Candidates sƒÖ ju≈º sorted by score (najmniejszy score = najbardziej zewnƒôtrzny)
                // Wiƒôc [0] = najbardziej zewnƒôtrzny r√≥g, zostaw TYLKO [0]!
                // To eliminuje problem z threshold - nie trzeba sprawdzaƒá czy "na tej samej linii"
                return corners.length > 0 ? [corners[0]] : [];
            }
            
            // Filtruj ka≈ºdƒÖ ƒáwiartkƒô
            const filteredTopLeft = filterDominatedCorners(topLeftCandidates, 'TL');
            const filteredTopRight = filterDominatedCorners(topRightCandidates, 'TR');
            const filteredBottomLeft = filterDominatedCorners(bottomLeftCandidates, 'BL');
            const filteredBottomRight = filterDominatedCorners(bottomRightCandidates, 'BR');
            
            console.log(`üî• After filtering dominated corners: TL=${filteredTopLeft.length}/${topLeftCandidates.length}, TR=${filteredTopRight.length}/${topRightCandidates.length}, BL=${filteredBottomLeft.length}/${bottomLeftCandidates.length}, BR=${filteredBottomRight.length}/${bottomRightCandidates.length}`);
            
            // v3.17: DIAGNOSTYKA - Sprawd≈∫ czy najbardziej zewnƒôtrzne rogi mogƒÖ utworzyƒá prostokƒÖt
            if (filteredTopLeft.length > 0 && filteredTopRight.length > 0 && 
                filteredBottomLeft.length > 0 && filteredBottomRight.length > 0) {
                const c_TL = filteredTopLeft[0];
                const c_TR = filteredTopRight[0];
                const c_BL = filteredBottomLeft[0];
                const c_BR = filteredBottomRight[0];
                
                console.log('\nüî¨ DIAGNOSTYKA NAJBARDZIEJ ZEWNƒòTRZNYCH ROG√ìW:');
                console.log(`   TL=(${c_TL.x}, ${c_TL.y}), TR=(${c_TR.x}, ${c_TR.y})`);
                console.log(`   BL=(${c_BL.x}, ${c_BL.y}), BR=(${c_BR.x}, ${c_BR.y})`);
                
                const w_test = c_TR.x - c_TL.x;
                const h_test = c_BL.y - c_TL.y;
                console.log(`   Width=${w_test}px, Height=${h_test}px`);
                
                // Test prostokƒÖtno≈õci
                const trx_dev = Math.abs(c_TR.x - (c_TL.x + w_test));
                const try_dev = Math.abs(c_TR.y - c_TL.y);
                const blx_dev = Math.abs(c_BL.x - c_TL.x);
                const bly_dev = Math.abs(c_BL.y - (c_TL.y + h_test));
                const brx_dev = Math.abs(c_BR.x - (c_TL.x + w_test));
                const bry_dev = Math.abs(c_BR.y - (c_TL.y + h_test));
                const max_dev = Math.max(trx_dev, try_dev, blx_dev, bly_dev, brx_dev, bry_dev);
                console.log(`   Rectangularity deviation: ${max_dev.toFixed(1)}px (max allowed: 50px) ${max_dev > 50 ? '‚ùå FAILED' : '‚úÖ OK'}`);
                
                // Test kƒÖt√≥w
                const topVec = { x: c_TR.x - c_TL.x, y: c_TR.y - c_TL.y };
                const leftVec = { x: c_BL.x - c_TL.x, y: c_BL.y - c_TL.y };
                const dot = topVec.x * leftVec.x + topVec.y * leftVec.y;
                const mag1 = Math.sqrt(topVec.x * topVec.x + topVec.y * topVec.y);
                const mag2 = Math.sqrt(leftVec.x * leftVec.x + leftVec.y * leftVec.y);
                const angle = Math.abs(Math.acos(Math.max(-1, Math.min(1, dot / (mag1 * mag2)))) * 180 / Math.PI);
                const angle_dev = Math.abs(angle - 90);
                console.log(`   TL corner angle: ${angle.toFixed(2)}¬∞ (deviation: ${angle_dev.toFixed(2)}¬∞, max allowed: 2¬∞) ${angle_dev > 2 ? '‚ùå FAILED' : '‚úÖ OK'}`);
            }
            
            
            // Pr√≥buj r√≥≈ºne kombinacje naro≈ºnik√≥w
            let bestFrame = null;
            let bestScore = 0;
            
            // Spr√≥buj top 3 kandydat√≥w z ka≈ºdej ƒáwiartki (PO filtrowaniu!)
            const maxCandidates = 3;
            
            let firstIterationDiagnostics = true;  // v3.18: Flag dla diagnostyki pierwszej iteracji
            
            for (let tl = 0; tl < Math.min(maxCandidates, filteredTopLeft.length); tl++) {
                for (let tr = 0; tr < Math.min(maxCandidates, filteredTopRight.length); tr++) {
                    for (let bl = 0; bl < Math.min(maxCandidates, filteredBottomLeft.length); bl++) {
                        for (let br = 0; br < Math.min(maxCandidates, filteredBottomRight.length); br++) {
                            const cornerTL = filteredTopLeft[tl];
                            const cornerTR = filteredTopRight[tr];
                            const cornerBL = filteredBottomLeft[bl];
                            const cornerBR = filteredBottomRight[br];
                            
                            // v3.18: DIAGNOSTYKA dla najbardziej zewnƒôtrznych rog√≥w (pierwsza iteracja)
                            const isFirstIteration = (tl === 0 && tr === 0 && bl === 0 && br === 0);
                            if (isFirstIteration && firstIterationDiagnostics) {
                                console.log('\nüî¨ PƒòTLA DIAGNOSTYKA (najbardziej zewnƒôtrzne rogi):');
                                console.log(`   Testing: TL=(${cornerTL.x},${cornerTL.y}), TR=(${cornerTR.x},${cornerTR.y}), BL=(${cornerBL.x},${cornerBL.y}), BR=(${cornerBR.x},${cornerBR.y})`);
                            }
                            
                            // Wymiary prostokƒÖta
                            const x = cornerTL.x;
                            const y = cornerTL.y;
                            const w = cornerTR.x - cornerTL.x;
                            const h = cornerBL.y - cornerTL.y;
                            
                            // Sprawd≈∫ czy to sensowny prostokƒÖt
                            if (w < 100 || h < 100 || w > width * 0.95 || h > height * 0.95) {
                                if (isFirstIteration && firstIterationDiagnostics) {
                                    console.log(`   ‚ùå SIZE TEST FAILED: w=${w} h=${h} (limits: 100-${(width*0.95).toFixed(0)} x 100-${(height*0.95).toFixed(0)})`);
                                    firstIterationDiagnostics = false;
                                }
                                continue;
                            }
                            if (isFirstIteration && firstIterationDiagnostics) {
                                console.log(`   ‚úÖ Size test OK: w=${w} h=${h}`);
                            }
                            
                            // Sprawd≈∫ PROSTOKƒÑTNO≈öƒÜ (4 naro≈ºniki muszƒÖ byƒá w rogach)
                            const topRightX = Math.abs(cornerTR.x - (x + w));
                            const topRightY = Math.abs(cornerTR.y - y);
                            const bottomLeftX = Math.abs(cornerBL.x - x);
                            const bottomLeftY = Math.abs(cornerBL.y - (y + h));
                            const bottomRightX = Math.abs(cornerBR.x - (x + w));
                            const bottomRightY = Math.abs(cornerBR.y - (y + h));
                            
                            const maxDeviation = Math.max(topRightX, topRightY, bottomLeftX, bottomLeftY, bottomRightX, bottomRightY);
                            
                            if (maxDeviation > 50) {
                                if (isFirstIteration && firstIterationDiagnostics) {
                                    console.log(`   ‚ùå RECTANGULARITY TEST FAILED: maxDeviation=${maxDeviation.toFixed(1)}px (max: 50px)`);
                                    firstIterationDiagnostics = false;
                                }
                                continue; // Naro≈ºniki nie tworzƒÖ prostokƒÖta
                            }
                            if (isFirstIteration && firstIterationDiagnostics) {
                                console.log(`   ‚úÖ Rectangularity test OK: maxDeviation=${maxDeviation.toFixed(1)}px`);
                            }
                            
                            // === v3.15: RECTANGULARITY CHECK (90¬∞ ¬±2¬∞) ===
                            // Sprawd≈∫ czy kƒÖty miƒôdzy krawƒôdziami sƒÖ bliskie 90¬∞
                            const topEdgeVec = { x: cornerTR.x - cornerTL.x, y: cornerTR.y - cornerTL.y };
                            const leftEdgeVec = { x: cornerBL.x - cornerTL.x, y: cornerBL.y - cornerTL.y };
                            const bottomEdgeVec = { x: cornerBR.x - cornerBL.x, y: cornerBR.y - cornerBL.y };
                            const rightEdgeVec = { x: cornerBR.x - cornerTR.x, y: cornerBR.y - cornerTR.y };
                            
                            // Funkcja pomocnicza do obliczania kƒÖta miƒôdzy wektorami
                            const getAngleDeg = (v1, v2) => {
                                const dot = v1.x * v2.x + v1.y * v2.y;
                                const mag1 = Math.sqrt(v1.x * v1.x + v1.y * v1.y);
                                const mag2 = Math.sqrt(v2.x * v2.x + v2.y * v2.y);
                                const cosAngle = dot / (mag1 * mag2);
                                return Math.abs(Math.acos(Math.max(-1, Math.min(1, cosAngle))) * 180 / Math.PI);
                            };
                            
                            // Sprawd≈∫ wszystkie 4 kƒÖty
                            const angleTL = getAngleDeg(topEdgeVec, leftEdgeVec);
                            const angleTR = getAngleDeg({ x: -topEdgeVec.x, y: -topEdgeVec.y }, rightEdgeVec);
                            const angleBL = getAngleDeg({ x: -leftEdgeVec.x, y: -leftEdgeVec.y }, bottomEdgeVec);
                            const angleBR = getAngleDeg({ x: -rightEdgeVec.x, y: -rightEdgeVec.y }, { x: -bottomEdgeVec.x, y: -bottomEdgeVec.y });
                            
                            // Wszystkie kƒÖty muszƒÖ byƒá 90¬∞ ¬±2¬∞
                            const angleDeviation = Math.max(
                                Math.abs(angleTL - 90),
                                Math.abs(angleTR - 90),
                                Math.abs(angleBL - 90),
                                Math.abs(angleBR - 90)
                            );
                            
                            if (angleDeviation > 2) {
                                if (isFirstIteration && firstIterationDiagnostics) {
                                    console.log(`   ‚ùå ANGLE TEST FAILED: angleDeviation=${angleDeviation.toFixed(2)}¬∞ (max: 2¬∞)`);
                                    console.log(`      TL=${angleTL.toFixed(2)}¬∞ TR=${angleTR.toFixed(2)}¬∞ BL=${angleBL.toFixed(2)}¬∞ BR=${angleBR.toFixed(2)}¬∞`);
                                    firstIterationDiagnostics = false;
                                }
                                continue; // KƒÖty nie sƒÖ wystarczajƒÖco bliskie 90¬∞
                            }
                            if (isFirstIteration && firstIterationDiagnostics) {
                                console.log(`   ‚úÖ Angle test OK: angleDeviation=${angleDeviation.toFixed(2)}¬∞`);
                            }
                            
                            // Sprawd≈∫ harmoniƒô kolor√≥w
                            const frameColors = [
                                cornerTL.hLine.color, cornerTL.vLine.color,
                                cornerTR.hLine.color, cornerTR.vLine.color,
                                cornerBL.hLine.color, cornerBL.vLine.color,
                                cornerBR.hLine.color, cornerBR.vLine.color
                            ];
                            
                            if (!colorsHaveCompatibleHue(frameColors)) {
                                if (isFirstIteration && firstIterationDiagnostics) {
                                    console.log(`   ‚ùå COLOR HARMONY TEST FAILED`);
                                    console.log(`      Colors:`, frameColors.map(c => `rgb(${c.r},${c.g},${c.b})`));
                                    firstIterationDiagnostics = false;
                                }
                                continue;
                            }
                            if (isFirstIteration && firstIterationDiagnostics) {
                                console.log(`   ‚úÖ Color harmony test OK`);
                            }
                            
                            // Sprawd≈∫ podobie≈Ñstwo kolor√≥w
                            const avgColor = {
                                r: frameColors.reduce((sum, c) => sum + c.r, 0) / frameColors.length,
                                g: frameColors.reduce((sum, c) => sum + c.g, 0) / frameColors.length,
                                b: frameColors.reduce((sum, c) => sum + c.b, 0) / frameColors.length
                            };
                            
                            const maxColorDiff = Math.max(...frameColors.map(c => colorDistance(c, avgColor)));
                            
                            if (maxColorDiff > 100) {
                                if (isFirstIteration && firstIterationDiagnostics) {
                                    console.log(`   ‚ùå COLOR SIMILARITY TEST FAILED: maxColorDiff=${maxColorDiff.toFixed(1)} (max: 100)`);
                                    console.log(`      Avg color: rgb(${avgColor.r.toFixed(0)},${avgColor.g.toFixed(0)},${avgColor.b.toFixed(0)})`);
                                    firstIterationDiagnostics = false;
                                }
                                continue;
                            }
                            if (isFirstIteration && firstIterationDiagnostics) {
                                console.log(`   ‚úÖ Color similarity test OK: maxColorDiff=${maxColorDiff.toFixed(1)}`);
                            }
                            
                            // === SPRAWDZENIE SYMETRII CORNER QUALITY ===
                            // Wszystkie 4 naro≈ºniki powinny mieƒá podobny quality
                            const cornerQualities = [
                                cornerTL.quality,
                                cornerTR.quality,
                                cornerBL.quality,
                                cornerBR.quality
                            ];
                            
                            const avgQuality = cornerQualities.reduce((sum, q) => sum + q, 0) / 4;
                            const minQuality = Math.min(...cornerQualities);
                            const maxQuality = Math.max(...cornerQualities);
                            
                            // Sprawd≈∫ gaps w ka≈ºdym naro≈ºniku
                            const cornerGaps = [
                                cornerTL.gap,
                                cornerTR.gap,
                                cornerBL.gap,
                                cornerBR.gap
                            ];
                            const maxGapInFrame = Math.max(...cornerGaps);
                            const avgGap = cornerGaps.reduce((sum, g) => sum + g, 0) / 4;
                            
                            // ODRZUƒÜ je≈õli:
                            // 1. Jeden naro≈ºnik jest du≈ºo gorszy od reszty
                            if (minQuality < avgQuality * 0.6) {
                                if (isFirstIteration && firstIterationDiagnostics) {
                                    console.log(`   ‚ùå QUALITY SYMMETRY TEST FAILED: minQuality=${minQuality.toFixed(2)} < avgQuality*0.6=${(avgQuality*0.6).toFixed(2)}`);
                                    console.log(`      Qualities: TL=${cornerTL.quality.toFixed(2)} TR=${cornerTR.quality.toFixed(2)} BL=${cornerBL.quality.toFixed(2)} BR=${cornerBR.quality.toFixed(2)}`);
                                    firstIterationDiagnostics = false;
                                }
                                continue;  // jeden naro≈ºnik jest s≈Çaby (>40% gorszy)
                            }
                            if (isFirstIteration && firstIterationDiagnostics) {
                                console.log(`   ‚úÖ Quality symmetry test OK: min=${minQuality.toFixed(2)} avg=${avgQuality.toFixed(2)}`);
                            }
                            
                            // 2. Jest du≈ºy rozrzut w quality
                            if (maxQuality - minQuality > 0.5) {
                                if (isFirstIteration && firstIterationDiagnostics) {
                                    console.log(`   ‚ùå QUALITY SPREAD TEST FAILED: spread=${(maxQuality-minQuality).toFixed(2)} > 0.5`);
                                    firstIterationDiagnostics = false;
                                }
                                continue;  // zbyt du≈ºa r√≥≈ºnica w quality
                            }
                            if (isFirstIteration && firstIterationDiagnostics) {
                                console.log(`   ‚úÖ Quality spread test OK: spread=${(maxQuality-minQuality).toFixed(2)}`);
                            }
                            
                            // 3. ≈öredni gap jest za du≈ºy (zmienione z 5 na 3 w v3.15)
                            if (avgGap > 3) {
                                if (isFirstIteration && firstIterationDiagnostics) {
                                    console.log(`   ‚ùå GAP TEST FAILED: avgGap=${avgGap.toFixed(1)}px > 3px`);
                                    console.log(`      Gaps: TL=${cornerTL.gap.toFixed(1)} TR=${cornerTR.gap.toFixed(1)} BL=${cornerBL.gap.toFixed(1)} BR=${cornerBR.gap.toFixed(1)}`);
                                    firstIterationDiagnostics = false;
                                }
                                continue;  // preferuj ramki z mniejszymi gaps
                            }
                            if (isFirstIteration && firstIterationDiagnostics) {
                                console.log(`   ‚úÖ Gap test OK: avgGap=${avgGap.toFixed(1)}px`);
                                console.log(`   üéâ ALL TESTS PASSED! This frame should be selected.`);
                                firstIterationDiagnostics = false;
                            }
                            
                            // SCORING - oblicz podstawowe metryki
                            const avgContinuity = (cornerTL.avgContinuity + cornerTR.avgContinuity + 
                                                   cornerBL.avgContinuity + cornerBR.avgContinuity) / 4;
                            const avgStrength = (cornerTL.strength + cornerTR.strength + 
                                                cornerBL.strength + cornerBR.strength) / 4;
                            const sizeRatio = (w * h) / (width * height);
                            
                            // === v3.15: OUTERMOST FRAME BIAS ===
                            // Oblicz luminancjƒô ramki (im ciemniejsza, tym lepiej)
                            const avgR = (avgColor.r);
                            const avgG = (avgColor.g);
                            const avgB = (avgColor.b);
                            const luminance = 0.299 * avgR + 0.587 * avgG + 0.114 * avgB; // Standard luminance formula
                            const darknessBonus = 1 + (1 - luminance / 255) * 0.5; // max +50% dla czarnych linii
                            
                            // Bonus za najwiƒôkszy obszar (outermost frame)
                            const areaBonus = Math.pow(sizeRatio, 1.2); // Lekki bonus dla wiƒôkszych ramek
                            
                            const rectangularityScore = 1 - (maxDeviation / 50); // im mniejsza dewiacja, tym lepiej
                            const angleScore = 1 - (angleDeviation / 2); // v3.15: bonus za lepsze kƒÖty
                            const colorSimilarityBonus = 1 + (1 - maxColorDiff / 100) * 0.3;
                            
                            // NEW: Corner quality bonus (im lepszy quality, tym wy≈ºszy bonus)
                            const cornerQualityBonus = 1 + avgQuality * 0.5;  // max +50% bonusu
                            
                            // NEW: Gap penalty (im mniejszy gap, tym lepiej) - v3.15: zaktualizowane do 3px
                            const gapPenalty = 1 - (avgGap / 3);  // max gap to 3, wiƒôc penalty 0-1
                            
                            
                            // v3.16: ROZSƒÑDNA position penalty (zamiast brutalnej 0.75^deviation)
                            const tlIdealSum = topLeftCandidates[0].x + topLeftCandidates[0].y;
                            const trIdealSum = (width - topRightCandidates[0].x) + topRightCandidates[0].y;
                            const blIdealSum = bottomLeftCandidates[0].x + (height - bottomLeftCandidates[0].y);
                            const brIdealSum = (width - bottomRightCandidates[0].x) + (height - bottomRightCandidates[0].y);
                            
                            const tlDeviation = (cornerTL.x + cornerTL.y) - tlIdealSum;
                            const trDeviation = ((width - cornerTR.x) + cornerTR.y) - trIdealSum;
                            const blDeviation = (cornerBL.x + (height - cornerBL.y)) - blIdealSum;
                            const brDeviation = ((width - cornerBR.x) + (height - cornerBR.y)) - brIdealSum;
                            
                            const maxPositionDeviationFiltered = Math.max(tlDeviation, trDeviation, blDeviation, brDeviation);
                            // v3.16: Nowa formu≈Ça: 1/(1+deviation/200)
                            // 0px ‚Üí 1.0, 100px ‚Üí 0.67, 200px ‚Üí 0.5, 400px ‚Üí 0.33
                            const positionPenaltyFiltered = 1 / (1 + maxPositionDeviationFiltered / 200);
                            
                            // v3.15: Zaktualizowany scoring z Outermost Frame Bias i Rectangularity Check
                            const score = avgContinuity * avgStrength * sizeRatio * areaBonus * rectangularityScore * 
                                          angleScore * darknessBonus * colorSimilarityBonus * cornerQualityBonus * 
                                          gapPenalty * positionPenaltyFiltered * 1000;
                            
                            if (score > bestScore) {
                                bestScore = score;
                                bestFrame = {
                                    x: x,
                                    y: y,
                                    width: w,
                                    height: h,
                                    score: score,
                                    corners: { topLeft: cornerTL, topRight: cornerTR, bottomLeft: cornerBL, bottomRight: cornerBR },
                                    avgContinuity: avgContinuity,
                                    maxDeviation: maxDeviation,
                                    cornerGaps: { TL: cornerTL.gap, TR: cornerTR.gap, BL: cornerBL.gap, BR: cornerBR.gap },
                                    avgGap: avgGap,
                                    avgQuality: avgQuality
                                };
                            }
                        }
                    }
                }
            }
            
            if (!bestFrame) {
                console.log('‚ö†Ô∏è No frame found with filtered corners, trying with ALL corners...');
                
                // FALLBACK: Spr√≥buj z TOP 3 z oryginalnych list (przed filtrowaniem)
                for (let tl = 0; tl < Math.min(3, topLeftCandidates.length); tl++) {
                    for (let tr = 0; tr < Math.min(3, topRightCandidates.length); tr++) {
                        for (let bl = 0; bl < Math.min(3, bottomLeftCandidates.length); bl++) {
                            for (let br = 0; br < Math.min(3, bottomRightCandidates.length); br++) {
                                const cornerTL = topLeftCandidates[tl];
                                const cornerTR = topRightCandidates[tr];
                                const cornerBL = bottomLeftCandidates[bl];
                                const cornerBR = bottomRightCandidates[br];
                                
                                // Wymiary prostokƒÖta
                                const x = cornerTL.x;
                                const y = cornerTL.y;
                                const w = cornerTR.x - cornerTL.x;
                                const h = cornerBL.y - cornerTL.y;
                                
                                // Sprawd≈∫ czy to sensowny prostokƒÖt
                                if (w < 100 || h < 100 || w > width * 0.95 || h > height * 0.95) {
                                    continue;
                                }
                                
                                // Sprawd≈∫ PROSTOKƒÑTNO≈öƒÜ (4 naro≈ºniki muszƒÖ byƒá w rogach)
                                const topRightX = Math.abs(cornerTR.x - (x + w));
                                const topRightY = Math.abs(cornerTR.y - y);
                                const bottomLeftX = Math.abs(cornerBL.x - x);
                                const bottomLeftY = Math.abs(cornerBL.y - (y + h));
                                const bottomRightX = Math.abs(cornerBR.x - (x + w));
                                const bottomRightY = Math.abs(cornerBR.y - (y + h));
                                
                                const maxDeviation = Math.max(topRightX, topRightY, bottomLeftX, bottomLeftY, bottomRightX, bottomRightY);
                                
                                if (maxDeviation > 50) {
                                    continue; // Naro≈ºniki nie tworzƒÖ prostokƒÖta
                                }
                                
                                // === v3.15: RECTANGULARITY CHECK (90¬∞ ¬±2¬∞) w fallback ===
                                const topEdgeVec = { x: cornerTR.x - cornerTL.x, y: cornerTR.y - cornerTL.y };
                                const leftEdgeVec = { x: cornerBL.x - cornerTL.x, y: cornerBL.y - cornerTL.y };
                                const bottomEdgeVec = { x: cornerBR.x - cornerBL.x, y: cornerBR.y - cornerBL.y };
                                const rightEdgeVec = { x: cornerBR.x - cornerTR.x, y: cornerBR.y - cornerTR.y };
                                
                                const getAngleDeg = (v1, v2) => {
                                    const dot = v1.x * v2.x + v1.y * v2.y;
                                    const mag1 = Math.sqrt(v1.x * v1.x + v1.y * v1.y);
                                    const mag2 = Math.sqrt(v2.x * v2.x + v2.y * v2.y);
                                    const cosAngle = dot / (mag1 * mag2);
                                    return Math.abs(Math.acos(Math.max(-1, Math.min(1, cosAngle))) * 180 / Math.PI);
                                };
                                
                                const angleTL = getAngleDeg(topEdgeVec, leftEdgeVec);
                                const angleTR = getAngleDeg({ x: -topEdgeVec.x, y: -topEdgeVec.y }, rightEdgeVec);
                                const angleBL = getAngleDeg({ x: -leftEdgeVec.x, y: -leftEdgeVec.y }, bottomEdgeVec);
                                const angleBR = getAngleDeg({ x: -rightEdgeVec.x, y: -rightEdgeVec.y }, { x: -bottomEdgeVec.x, y: -bottomEdgeVec.y });
                                
                                const angleDeviation = Math.max(
                                    Math.abs(angleTL - 90),
                                    Math.abs(angleTR - 90),
                                    Math.abs(angleBL - 90),
                                    Math.abs(angleBR - 90)
                                );
                                
                                if (angleDeviation > 2) {
                                    continue;
                                }
                                
                                // Sprawd≈∫ harmoniƒô kolor√≥w
                                const frameColors = [
                                    cornerTL.hLine.color, cornerTL.vLine.color,
                                    cornerTR.hLine.color, cornerTR.vLine.color,
                                    cornerBL.hLine.color, cornerBL.vLine.color,
                                    cornerBR.hLine.color, cornerBR.vLine.color
                                ];
                                
                                if (!colorsHaveCompatibleHue(frameColors)) {
                                    continue;
                                }
                                
                                // Sprawd≈∫ podobie≈Ñstwo kolor√≥w
                                const avgColor = {
                                    r: frameColors.reduce((sum, c) => sum + c.r, 0) / frameColors.length,
                                    g: frameColors.reduce((sum, c) => sum + c.g, 0) / frameColors.length,
                                    b: frameColors.reduce((sum, c) => sum + c.b, 0) / frameColors.length
                                };
                                
                                const maxColorDiff = Math.max(...frameColors.map(c => colorDistance(c, avgColor)));
                                
                                if (maxColorDiff > 100) {
                                    continue;
                                }
                                
                                // Sprawd≈∫ quality i gaps
                                const cornerQualities = [cornerTL.quality, cornerTR.quality, cornerBL.quality, cornerBR.quality];
                                const avgQuality = cornerQualities.reduce((sum, q) => sum + q, 0) / 4;
                                const minQuality = Math.min(...cornerQualities);
                                const maxQuality = Math.max(...cornerQualities);
                                
                                const cornerGaps = [cornerTL.gap, cornerTR.gap, cornerBL.gap, cornerBR.gap];
                                const avgGap = cornerGaps.reduce((sum, g) => sum + g, 0) / 4;
                                
                                if (minQuality < avgQuality * 0.6) {
                                    continue;
                                }
                                
                                if (maxQuality - minQuality > 0.5) {
                                    continue;
                                }
                                
                                if (avgGap > 3) {
                                    continue;
                                }
                                
                                // === v3.15: OUTERMOST FRAME BIAS w fallback ===
                                const avgR = (avgColor.r);
                                const avgG = (avgColor.g);
                                const avgB = (avgColor.b);
                                const luminance = 0.299 * avgR + 0.587 * avgG + 0.114 * avgB;
                                const darknessBonus = 1 + (1 - luminance / 255) * 0.5;
                                const areaBonus = Math.pow((w * h) / (width * height), 1.2);
                                
                                // SCORING FALLBACK - priorytetyzuj bardziej ZEWNƒòTRZNE kombinacje!
                                const avgContinuity = (cornerTL.avgContinuity + cornerTR.avgContinuity + 
                                                       cornerBL.avgContinuity + cornerBR.avgContinuity) / 4;
                                const avgStrength = (cornerTL.strength + cornerTR.strength + 
                                                    cornerBL.strength + cornerBR.strength) / 4;
                                const sizeRatio = (w * h) / (width * height);
                                const rectangularityScore = 1 - (maxDeviation / 50);
                                const angleScore = 1 - (angleDeviation / 2);
                                const colorSimilarityBonus = 1 + (1 - maxColorDiff / 100) * 0.3;
                                const cornerQualityBonus = 1 + avgQuality * 0.5;
                                const gapPenalty = 1 - (avgGap / 3);
                                
                                // v3.16: ROZSƒÑDNA position penalty (zamiast brutalnej 0.75^deviation)
                                // Preferujemy najbardziej zewnƒôtrzne rogi, ale nie zerujemy score ca≈Çkowicie
                                const tlIdealSum = topLeftCandidates[0].x + topLeftCandidates[0].y;
                                const trIdealSum = (width - topRightCandidates[0].x) + topRightCandidates[0].y;
                                const blIdealSum = bottomLeftCandidates[0].x + (height - bottomLeftCandidates[0].y);
                                const brIdealSum = (width - bottomRightCandidates[0].x) + (height - bottomRightCandidates[0].y);
                                
                                const tlDeviation = (cornerTL.x + cornerTL.y) - tlIdealSum;
                                const trDeviation = ((width - cornerTR.x) + cornerTR.y) - trIdealSum;
                                const blDeviation = (cornerBL.x + (height - cornerBL.y)) - blIdealSum;
                                const brDeviation = ((width - cornerBR.x) + (height - cornerBR.y)) - brIdealSum;
                                
                                const maxPositionDeviation = Math.max(tlDeviation, trDeviation, blDeviation, brDeviation);
                                // v3.16: Nowa formu≈Ça: 1/(1+deviation/200)
                                // 0px ‚Üí 1.0, 100px ‚Üí 0.67, 200px ‚Üí 0.5, 400px ‚Üí 0.33
                                const positionPenalty = 1 / (1 + maxPositionDeviation / 200);
                                
                                // v3.15: Zaktualizowany scoring
                                const score = avgContinuity * avgStrength * sizeRatio * areaBonus * rectangularityScore * 
                                              angleScore * darknessBonus * colorSimilarityBonus * cornerQualityBonus * 
                                              gapPenalty * positionPenalty * 1000;
                                
                                if (score > bestScore) {
                                    bestScore = score;
                                    bestFrame = {
                                        x: x,
                                        y: y,
                                        width: w,
                                        height: h,
                                        score: score,
                                        corners: { topLeft: cornerTL, topRight: cornerTR, bottomLeft: cornerBL, bottomRight: cornerBR },
                                        avgContinuity: avgContinuity,
                                        maxDeviation: maxDeviation,
                                        cornerGaps: { TL: cornerTL.gap, TR: cornerTR.gap, BL: cornerBL.gap, BR: cornerBR.gap },
                                        avgGap: avgGap,
                                        avgQuality: avgQuality
                                    };
                                }
                            }
                        }
                    }
                }
                
                if (bestFrame) {
                    console.log('‚úÖ Found frame using fallback (unfiltered corners)');
                    
                    // Debug: Position penalty
                    const tlIdealSum = topLeftCandidates[0].x + topLeftCandidates[0].y;
                    const trIdealSum = (width - topRightCandidates[0].x) + topRightCandidates[0].y;
                    const blIdealSum = bottomLeftCandidates[0].x + (height - bottomLeftCandidates[0].y);
                    const brIdealSum = (width - bottomRightCandidates[0].x) + (height - bottomRightCandidates[0].y);
                    
                    const tlDev = (bestFrame.corners.topLeft.x + bestFrame.corners.topLeft.y) - tlIdealSum;
                    const trDev = ((width - bestFrame.corners.topRight.x) + bestFrame.corners.topRight.y) - trIdealSum;
                    const blDev = (bestFrame.corners.bottomLeft.x + (height - bestFrame.corners.bottomLeft.y)) - blIdealSum;
                    const brDev = ((width - bestFrame.corners.bottomRight.x) + (height - bestFrame.corners.bottomRight.y)) - brIdealSum;
                    
                    const maxDev = Math.max(tlDev, trDev, blDev, brDev);
                    console.log('üìç Position deviation from ideal corners:');
                    console.log(`   TL: ${tlDev.toFixed(1)}px, TR: ${trDev.toFixed(1)}px, BL: ${blDev.toFixed(1)}px, BR: ${brDev.toFixed(1)}px`);
                    const penaltyValue = 1 / (1 + maxDev / 200);  // v3.17: u≈ºywam NOWEJ formu≈Çy w logu
                    console.log(`   Max: ${maxDev.toFixed(1)}px ‚Üí penalty: ${penaltyValue.toFixed(4)} (new formula: 1/(1+dev/200))`);
                }
            }
            
            if (!bestFrame) {
                console.log('‚ùå NO VALID FRAME FOUND from corners!');
                console.log('   Reason: No valid rectangle formed by 4 corners.');
                return null;
            }
            
            // === DYNAMICZNA KOREKTA LINII: Przesuniƒôcie do ≈õrodk√≥w linii ===
            // Oblicz rzeczywistƒÖ grubo≈õƒá linii na podstawie edge detection
            const topLine = bestFrame.corners.topLeft.hLine;
            const leftLine = bestFrame.corners.topLeft.vLine;
            
            const lineThickness = calculateLineThickness(topLine, leftLine, edges, width, height);
            
            // Offset = po≈Çowa grubo≈õci linii (≈ºeby byƒá w ≈õrodku)
            // WA≈ªNE: Contrast detection mo≈ºe wykrywaƒá od wewnƒôtrznej krawƒôdzi!
            // Dlatego offset musi byƒá MINIMALNY (max 1px) ≈ºeby nie przesunƒÖƒá za bardzo
            let centerOffset = Math.round(lineThickness / 2);
            centerOffset = Math.max(0, Math.min(1, centerOffset));  // Maksimum 1px!
            
            console.log(`üìè Dynamic line center correction:`);
            console.log(`   Detected line thickness: ${lineThickness.toFixed(1)}px`);
            console.log(`   Calculated offset: ${centerOffset}px (half of thickness)`);
            console.log(`   Before correction: (${Math.round(bestFrame.x)}, ${Math.round(bestFrame.y)}) ${Math.round(bestFrame.width)}x${Math.round(bestFrame.height)}`);
            
            // Przesu≈Ñ ramkƒô do ≈õrodka
            bestFrame.x += centerOffset;
            bestFrame.y += centerOffset;
            bestFrame.width -= 2 * centerOffset;
            bestFrame.height -= 2 * centerOffset;
            
            console.log(`   After correction: (${Math.round(bestFrame.x)}, ${Math.round(bestFrame.y)}) ${Math.round(bestFrame.width)}x${Math.round(bestFrame.height)}`);
            
            console.log(`‚úÖ SELECTED FRAME (from corners):`);
            console.log(`   Position: (${Math.round(bestFrame.x)}, ${Math.round(bestFrame.y)})`);
            console.log(`   Size: ${Math.round(bestFrame.width)} x ${Math.round(bestFrame.height)}`);
            console.log(`   Avg continuity: ${(bestFrame.avgContinuity * 100).toFixed(0)}%`);
            console.log(`   Max corner deviation: ${bestFrame.maxDeviation.toFixed(1)}px`);
            console.log(`   Corner gaps: TL=${bestFrame.cornerGaps.TL.toFixed(1)}px, TR=${bestFrame.cornerGaps.TR.toFixed(1)}px, BL=${bestFrame.cornerGaps.BL.toFixed(1)}px, BR=${bestFrame.cornerGaps.BR.toFixed(1)}px`);
            console.log(`   Avg gap: ${bestFrame.avgGap.toFixed(1)}px (max allowed: 5px)`);
            console.log(`   Avg quality: ${(bestFrame.avgQuality * 100).toFixed(0)}%`);
            console.log(`   Score: ${bestScore.toFixed(1)}`);
            
            return bestFrame;
        }
        
        function findBestChartFrame(hLines, vLines, width, height, imageData, edges) {
            console.log('‚ïî‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïó');
            console.log('‚ïë       v3.18: Loop Diagnostics              ‚ïë');
            console.log('‚ïö‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïù');
            
            // === v3.15: Wykryj WSZYSTKIE naro≈ºniki z 3px gap tolerance ===
            console.log(`Input lines: ${hLines.length} H-lines, ${vLines.length} V-lines`);
            
            // Krok 1: Wykryj wszystkie naro≈ºniki
            const corners = detectCorners(hLines, vLines, 10);
            
            if (corners.length < 4) {
                console.log(`‚ö†Ô∏è Not enough corners detected (${corners.length}), falling back to line-based detection`);
                // Fallback do starej metody
                const solidH = hLines.filter(l => l.continuity > 0.7);
                const solidV = vLines.filter(l => l.continuity > 0.7);
                
                if (solidH.length >= 2 && solidV.length >= 2) {
                    return findFrameFromQuadrants(solidH, solidV, width, height, imageData);
                }
                
                return null;
            }
            
            // Krok 2: Znajd≈∫ ramkƒô z naro≈ºnik√≥w
            const frameFromCorners = findFrameFromCorners(corners, width, height, imageData, edges);
            
            if (frameFromCorners) {
                return frameFromCorners;
            }
            
            // Fallback: Je≈õli corner detection zawi√≥d≈Ç, spr√≥buj line-based
            console.log('‚ö†Ô∏è Corner-based detection failed, trying line-based detection...');
            const solidH = hLines.filter(l => l.continuity > 0.85);
            const solidV = vLines.filter(l => l.continuity > 0.85);
            
            console.log(`Solid lines: ${solidH.length} H-lines, ${solidV.length} V-lines (continuity >85%)`);
            
            if (solidH.length < 2 || solidV.length < 2) {
                console.log('‚ö†Ô∏è Not enough solid lines, lowering threshold to 70%');
                const fallbackH = hLines.filter(l => l.continuity > 0.7);
                const fallbackV = vLines.filter(l => l.continuity > 0.7);
                return findFrameFromQuadrants(fallbackH, fallbackV, width, height, imageData);
            }
            
            return findFrameFromQuadrants(solidH, solidV, width, height, imageData);
        }
        
        function findFrameFromQuadrants(hLines, vLines, width, height, imageData) {
            // === PODZIEL MAPƒò NA 4 ƒÜWIARTKI ===
            const midX = width / 2;
            const midY = height / 2;
            const margin = Math.min(width, height) * 0.05; // 5% margines od brzegu
            
            console.log(`Map divided: midX=${Math.round(midX)}, midY=${Math.round(midY)}, margin=${Math.round(margin)}`);
            
            // === EKSTRAKCJA KOLOR√ìW DLA WSZYSTKICH LINII ===
            console.log('üé® Extracting line colors...');
            hLines.forEach(line => {
                line.color = extractLineColor(imageData, width, height, line, true);
            });
            vLines.forEach(line => {
                line.color = extractLineColor(imageData, width, height, line, false);
            });
            
            // === ƒÜWIARTKA 1: G√ìRA (TOP) ===
            // Szukamy najbardziej G√ìRNEJ solidnej linii (ale NIE przy brzegu kartki!)
            const edgeMargin = Math.max(10, Math.min(width, height) * 0.02); // 10px minimum lub 2% od brzegu
            
            const topCandidates = hLines
                .filter(l => l.y > margin && l.y < midY)
                .filter(l => l.y > edgeMargin) // NIE przy samym brzegu!
                .filter(l => l.x1 > edgeMargin && l.x2 < width - edgeMargin) // ko≈Ñce NIE przy brzegu!
                .sort((a, b) => a.y - b.y); // sortuj od g√≥ry
            
            // === ƒÜWIARTKA 2: D√ì≈Å (BOTTOM) ===
            const bottomCandidates = hLines
                .filter(l => l.y > midY && l.y < height - margin)
                .filter(l => l.y < height - edgeMargin) // NIE przy samym brzegu!
                .filter(l => l.x1 > edgeMargin && l.x2 < width - edgeMargin) // ko≈Ñce NIE przy brzegu!
                .sort((a, b) => b.y - a.y); // sortuj od do≈Çu
            
            // === ƒÜWIARTKA 3: LEWA (LEFT) ===
            const leftCandidates = vLines
                .filter(l => l.x > margin && l.x < midX)
                .filter(l => l.x > edgeMargin) // NIE przy samym brzegu!
                .filter(l => l.y1 > edgeMargin && l.y2 < height - edgeMargin) // ko≈Ñce NIE przy brzegu!
                .sort((a, b) => a.x - b.x); // sortuj od lewej
            
            // === ƒÜWIARTKA 4: PRAWA (RIGHT) ===
            const rightCandidates = vLines
                .filter(l => l.x > midX && l.x < width - margin)
                .filter(l => l.x < width - edgeMargin) // NIE przy samym brzegu!
                .filter(l => l.y1 > edgeMargin && l.y2 < height - edgeMargin) // ko≈Ñce NIE przy brzegu!
                .sort((a, b) => b.x - a.x); // sortuj od prawej
            
            console.log(`Edge margin: ${Math.round(edgeMargin)}px (lines within this distance from edge are rejected)`);
            console.log(`Quadrant candidates: TOP=${topCandidates.length}, BOTTOM=${bottomCandidates.length}, LEFT=${leftCandidates.length}, RIGHT=${rightCandidates.length}`);
            
            if (topCandidates.length === 0 || bottomCandidates.length === 0 || 
                leftCandidates.length === 0 || rightCandidates.length === 0) {
                console.log('‚ö†Ô∏è Missing lines in some quadrants, using fallback');
                return {
                    x: margin, y: margin,
                    width: width - 2 * margin,
                    height: height - 2 * margin,
                    score: 0, cornersConnected: 0, avgContinuity: 0
                };
            }
            
            // === TESTUJ KOMBINACJE: we≈∫ top 3 z ka≈ºdej ƒáwiartki ===
            let bestFrame = null;
            let bestScore = 0;
            
            for (let ti = 0; ti < Math.min(3, topCandidates.length); ti++) {
                for (let bi = 0; bi < Math.min(3, bottomCandidates.length); bi++) {
                    const topLine = topCandidates[ti];
                    const bottomLine = bottomCandidates[bi];
                    const h = bottomLine.y - topLine.y;
                    
                    // Ramka musi mieƒá sensowny rozmiar
                    if (h < height * 0.4 || h > height * 0.95) continue;
                    
                    for (let li = 0; li < Math.min(3, leftCandidates.length); li++) {
                        for (let ri = 0; ri < Math.min(3, rightCandidates.length); ri++) {
                            const leftLine = leftCandidates[li];
                            const rightLine = rightCandidates[ri];
                            const w = rightLine.x - leftLine.x;
                            
                            if (w < width * 0.4 || w > width * 0.95) continue;
                            
                            const aspectRatio = w / h;
                            if (aspectRatio < 0.6 || aspectRatio > 2.8) continue;
                            
                            // === SPRAWD≈π CZY TO JEST FAKTYCZNY PROSTOKƒÑT ===
                            
                            // KROK 1: Sprawd≈∫ czy linie poziome majƒÖ podobnƒÖ d≈Çugo≈õƒá
                            const topLength = topLine.x2 - topLine.x1;
                            const bottomLength = bottomLine.x2 - bottomLine.x1;
                            const hLengthDiff = Math.abs(topLength - bottomLength);
                            
                            if (hLengthDiff > Math.min(topLength, bottomLength) * 0.15) {
                                // R√≥≈ºnica > 15% ‚Üí to nie prostokƒÖt!
                                continue;
                            }
                            
                            // KROK 2: Sprawd≈∫ czy linie pionowe majƒÖ podobnƒÖ d≈Çugo≈õƒá
                            const leftLength = leftLine.y2 - leftLine.y1;
                            const rightLength = rightLine.y2 - rightLine.y1;
                            const vLengthDiff = Math.abs(leftLength - rightLength);
                            
                            if (vLengthDiff > Math.min(leftLength, rightLength) * 0.15) {
                                // R√≥≈ºnica > 15% ‚Üí to nie prostokƒÖt!
                                continue;
                            }
                            
                            // KROK 3: OSTRO sprawd≈∫ wszystkie 4 naro≈ºniki
                            // Ka≈ºdy r√≥g MUSI mieƒá zar√≥wno X jak i Y pasujƒÖce!
                            let cornersConnected = 0;
                            const cornerTolerance = 15;
                            
                            // Top-left: linia TOP zaczyna siƒô (x1) TAM gdzie linia LEFT jest (x)
                            //           oraz linia LEFT zaczyna siƒô (y1) TAM gdzie linia TOP jest (y)
                            if (Math.abs(topLine.x1 - leftLine.x) <= cornerTolerance &&
                                Math.abs(leftLine.y1 - topLine.y) <= cornerTolerance) {
                                cornersConnected++;
                            }
                            
                            // Top-right: linia TOP ko≈Ñczy siƒô (x2) TAM gdzie linia RIGHT jest (x)
                            //            oraz linia RIGHT zaczyna siƒô (y1) TAM gdzie linia TOP jest (y)
                            if (Math.abs(topLine.x2 - rightLine.x) <= cornerTolerance &&
                                Math.abs(rightLine.y1 - topLine.y) <= cornerTolerance) {
                                cornersConnected++;
                            }
                            
                            // Bottom-left: linia BOTTOM zaczyna siƒô (x1) TAM gdzie linia LEFT jest (x)
                            //              oraz linia LEFT ko≈Ñczy siƒô (y2) TAM gdzie linia BOTTOM jest (y)
                            if (Math.abs(bottomLine.x1 - leftLine.x) <= cornerTolerance &&
                                Math.abs(leftLine.y2 - bottomLine.y) <= cornerTolerance) {
                                cornersConnected++;
                            }
                            
                            // Bottom-right: linia BOTTOM ko≈Ñczy siƒô (x2) TAM gdzie linia RIGHT jest (x)
                            //               oraz linia RIGHT ko≈Ñczy siƒô (y2) TAM gdzie linia BOTTOM jest (y)
                            if (Math.abs(bottomLine.x2 - rightLine.x) <= cornerTolerance &&
                                Math.abs(rightLine.y2 - bottomLine.y) <= cornerTolerance) {
                                cornersConnected++;
                            }
                            
                            // WYMAGANE: WSZYSTKIE 4 NARO≈ªNIKI! (nie 3/4)
                            if (cornersConnected < 4) {
                                if (cornersConnected >= 3) {
                                    console.log(`‚ö†Ô∏è Rejected: only ${cornersConnected}/4 corners (required 4/4 for solid rectangle)`);
                                }
                                continue;
                            }
                            
                            // KROK 4: Sprawd≈∫ czy linie ZAWIERAJƒÑ ca≈Çy zakres prostokƒÖta
                            // Linia TOP musi siƒôgaƒá od LEFT.x do RIGHT.x
                            const topCoversWidth = (topLine.x1 <= leftLine.x + cornerTolerance) && 
                                                   (topLine.x2 >= rightLine.x - cornerTolerance);
                            
                            // Linia BOTTOM musi siƒôgaƒá od LEFT.x do RIGHT.x
                            const bottomCoversWidth = (bottomLine.x1 <= leftLine.x + cornerTolerance) && 
                                                      (bottomLine.x2 >= rightLine.x - cornerTolerance);
                            
                            // Linia LEFT musi siƒôgaƒá od TOP.y do BOTTOM.y
                            const leftCoversHeight = (leftLine.y1 <= topLine.y + cornerTolerance) && 
                                                     (leftLine.y2 >= bottomLine.y - cornerTolerance);
                            
                            // Linia RIGHT musi siƒôgaƒá od TOP.y do BOTTOM.y
                            const rightCoversHeight = (rightLine.y1 <= topLine.y + cornerTolerance) && 
                                                      (rightLine.y2 >= bottomLine.y - cornerTolerance);
                            
                            if (!topCoversWidth || !bottomCoversWidth || !leftCoversHeight || !rightCoversHeight) {
                                console.log(`‚ö†Ô∏è Rejected: lines don't cover full rectangle`);
                                continue;
                            }
                            
                            // === KLUCZOWE: SPRAWD≈π PODOBIE≈ÉSTWO KOLOR√ìW ===
                            // Ramka musi sk≈Çadaƒá siƒô z linii tego samego koloru!
                            
                            // KROK 1: Sprawd≈∫ harmoniƒô kolorystycznƒÖ (charakter koloru)
                            const frameColors = [topLine.color, bottomLine.color, leftLine.color, rightLine.color];
                            if (!colorsHaveCompatibleHue(frameColors)) {
                                console.log(`‚ùå Rejected frame: incompatible color hues (neutral vs saturated)`);
                                continue;
                            }
                            
                            // KROK 2: Sprawd≈∫ odleg≈Ço≈õƒá RGB (r√≥≈ºne odcienie tego samego typu)
                            const colorThreshold = 100; // zwiƒôkszone z 50 do 100 dla odcieni szaro≈õci
                            
                            // Oblicz ≈õredni kolor z 4 linii
                            const avgColor = {
                                r: (topLine.color.r + bottomLine.color.r + leftLine.color.r + rightLine.color.r) / 4,
                                g: (topLine.color.g + bottomLine.color.g + leftLine.color.g + rightLine.color.g) / 4,
                                b: (topLine.color.b + bottomLine.color.b + leftLine.color.b + rightLine.color.b) / 4
                            };
                            
                            // Sprawd≈∫ czy wszystkie linie sƒÖ zbli≈ºone kolorystycznie do ≈õredniej
                            const topColorDiff = colorDistance(topLine.color, avgColor);
                            const bottomColorDiff = colorDistance(bottomLine.color, avgColor);
                            const leftColorDiff = colorDistance(leftLine.color, avgColor);
                            const rightColorDiff = colorDistance(rightLine.color, avgColor);
                            
                            const maxColorDiff = Math.max(topColorDiff, bottomColorDiff, leftColorDiff, rightColorDiff);
                            
                            // Je≈õli kt√≥ra≈õ linia ma drastycznie inny odcie≈Ñ - odrzuƒá tƒô kombinacjƒô!
                            if (maxColorDiff > colorThreshold) {
                                console.log(`‚ùå Rejected frame: color distance too large (max diff=${maxColorDiff.toFixed(0)} > ${colorThreshold})`);
                                continue;
                            }
                            
                            // Bonus za bardzo podobne odcienie
                            const colorSimilarityBonus = 1 + (1 - maxColorDiff / colorThreshold) * 0.3; // max +30%
                            
                            // === SCORING ===
                            const avgContinuity = (topLine.continuity + bottomLine.continuity + 
                                                   leftLine.continuity + rightLine.continuity) / 4;
                            const sizeRatio = (w * h) / (width * height);
                            const cornerBonus = Math.pow(cornersConnected / 4, 1.5);
                            
                            // BONUS za zewnƒôtrzno≈õƒá (ale w ramach ƒáwiartek!)
                            const topness = 1 - (topLine.y / midY);      // im bli≈ºej g√≥ry, tym lepiej
                            const bottomness = 1 - ((height - bottomLine.y) / midY);
                            const leftness = 1 - (leftLine.x / midX);
                            const rightness = 1 - ((width - rightLine.x) / midX);
                            const outernessBonus = (topness + bottomness + leftness + rightness) / 4;
                            
                            const score = cornerBonus * avgContinuity * sizeRatio * (1 + outernessBonus) * colorSimilarityBonus * 1000;
                            
                            if (score > bestScore) {
                                bestScore = score;
                                bestFrame = {
                                    x: leftLine.x,
                                    y: topLine.y,
                                    width: w,
                                    height: h,
                                    score: score,
                                    cornersConnected: cornersConnected,
                                    avgContinuity: avgContinuity,
                                    lines: { top: topLine, bottom: bottomLine, left: leftLine, right: rightLine }
                                };
                            }
                        }
                    }
                }
            }
            
            if (!bestFrame) {
                console.log('‚ùå NO VALID FRAME FOUND!');
                console.log('   Reason: No rectangle with 4/4 connected corners detected.');
                console.log('   This means the detected lines do not form a proper closed rectangle.');
                return null;
            }
            
            console.log(`‚úÖ SELECTED FRAME:`);
            console.log(`   Position: (${Math.round(bestFrame.x)}, ${Math.round(bestFrame.y)})`);
            console.log(`   Size: ${Math.round(bestFrame.width)} x ${Math.round(bestFrame.height)}`);
            console.log(`   Corners: ${bestFrame.cornersConnected}/4 connected`);
            console.log(`   Continuity: ${(bestFrame.avgContinuity * 100).toFixed(0)}%`);
            console.log(`   Score: ${bestScore.toFixed(1)}`);
            
            // Debug: poka≈º kolory linii ramki
            if (bestFrame.lines) {
                const avgR = Math.round((bestFrame.lines.top.color.r + bestFrame.lines.bottom.color.r + 
                                        bestFrame.lines.left.color.r + bestFrame.lines.right.color.r) / 4);
                const avgG = Math.round((bestFrame.lines.top.color.g + bestFrame.lines.bottom.color.g + 
                                        bestFrame.lines.left.color.g + bestFrame.lines.right.color.g) / 4);
                const avgB = Math.round((bestFrame.lines.top.color.b + bestFrame.lines.bottom.color.b + 
                                        bestFrame.lines.left.color.b + bestFrame.lines.right.color.b) / 4);
                console.log(`   Frame color: RGB(${avgR}, ${avgG}, ${avgB})`);
            }
            
            return bestFrame;
        }

        function detectFrame(ctx, width, height) {
            const imageData = ctx.getImageData(0, 0, width, height);
            const data = imageData.data;
            
            // === KROK 1: Opcjonalne sharpening dla starych PDF ===
            // Wykryj czy PDF ma niski kontrast (stary, skompresowany)
            let processedData = data;
            let needsSharpening = false;
            
            // Sample 100 losowych pikseli ≈ºeby sprawdziƒá ≈õredni kontrast
            let totalContrast = 0;
            const samples = 100;
            for (let i = 0; i < samples; i++) {
                const x = Math.floor(Math.random() * (width - 4)) + 2;
                const y = Math.floor(Math.random() * (height - 4)) + 2;
                const idx = (y * width + x) * 4;
                
                const center = (data[idx] + data[idx+1] + data[idx+2]) / 3;
                let surroundSum = 0;
                for (let dy = -1; dy <= 1; dy++) {
                    for (let dx = -1; dx <= 1; dx++) {
                        if (dx === 0 && dy === 0) continue;
                        const si = ((y + dy) * width + (x + dx)) * 4;
                        surroundSum += (data[si] + data[si+1] + data[si+2]) / 3;
                    }
                }
                const surroundAvg = surroundSum / 8;
                totalContrast += Math.abs(center - surroundAvg);
            }
            const avgContrast = totalContrast / samples;
            
            if (avgContrast < 15) {
                needsSharpening = true;
                console.log(`üìä Low contrast detected (avg=${avgContrast.toFixed(1)}), applying sharpening...`);
                processedData = sharpenImage(data, width, height);
            } else {
                console.log(`üìä Normal contrast detected (avg=${avgContrast.toFixed(1)}), no sharpening needed`);
            }
            
            // === KROK 2: Gaussian Blur dla redukcji szumu ===
            const blurred = gaussianBlur(processedData, width, height);
            
            // === KROK 3A: Sobel edge detection ===
            const sobelEdges = new Float32Array(width * height);
            const sobelStrength = new Float32Array(width * height);
            
            for (let y = 1; y < height - 1; y++) {
                for (let x = 1; x < width - 1; x++) {
                    const idx = y * width + x;
                    
                    // Pobierz okoliczne piksele (grayscale)
                    const p = [];
                    for (let dy = -1; dy <= 1; dy++) {
                        for (let dx = -1; dx <= 1; dx++) {
                            const i = ((y + dy) * width + (x + dx)) * 4;
                            p.push((blurred[i] + blurred[i+1] + blurred[i+2]) / 3);
                        }
                    }
                    
                    // Sobel X i Y
                    const gx = -p[0] - 2*p[3] - p[6] + p[2] + 2*p[5] + p[8];
                    const gy = -p[0] - 2*p[1] - p[2] + p[6] + 2*p[7] + p[8];
                    
                    const magnitude = Math.sqrt(gx * gx + gy * gy);
                    sobelStrength[idx] = magnitude;
                    
                    if (magnitude > edgeThreshold) {
                        sobelEdges[idx] = 1;
                    }
                }
            }
            
            // === KROK 3B: Contrast-based detection dla cienkich linii ===
            const contrastResult = detectThinLines(processedData, width, height, 15);
            const contrastEdges = contrastResult.edges;
            const contrastStrength = contrastResult.strength;
            
            // === KROK 3C: Po≈ÇƒÖcz oba wykrycia (Sobel + Contrast) ===
            const combinedEdges = new Float32Array(width * height);
            const combinedStrength = new Float32Array(width * height);
            
            for (let i = 0; i < width * height; i++) {
                // Piksel jest krawƒôdziƒÖ je≈õli wykryty ALBO przez Sobel ALBO przez contrast
                if (sobelEdges[i] === 1 || contrastEdges[i] === 1) {
                    combinedEdges[i] = 1;
                    // U≈ºyj wiƒôkszej si≈Çy
                    combinedStrength[i] = Math.max(sobelStrength[i], contrastStrength[i]);
                }
            }
            
            console.log(`üéØ Edge detection: Sobel + Contrast-based (for thin lines)`);
            
            // === KROK 4: Wykrywanie linii z analiza grubo≈õci ===
            const horizontalLines = findRobustLines(combinedEdges, combinedStrength, width, height, true);
            const verticalLines = findRobustLines(combinedEdges, combinedStrength, width, height, false);
            
            console.log(`Detected ${horizontalLines.length} H-lines, ${verticalLines.length} V-lines`);
            
            if (horizontalLines.length < 2 || verticalLines.length < 2) {
                console.log('‚ö†Ô∏è  Not enough lines, using full page');
                return {
                    x: 0, y: 0, width: width, height: height,
                    debugInfo: {
                        hLinesCount: horizontalLines.length,
                        vLinesCount: verticalLines.length,
                        topY: 0, bottomY: height, leftX: 0, rightX: width
                    }
                };
            }
            
            // === KROK 5: Grupowanie bliskich linii ===
            const groupedHLines = groupCloseLines(horizontalLines, true, height);
            const groupedVLines = groupCloseLines(verticalLines, false, width);
            
            console.log(`After grouping: ${groupedHLines.length} H-groups, ${groupedVLines.length} V-groups`);
            
            // === KROK 6: Inteligentne znajdowanie ramki ===
            const bestFrame = findBestChartFrame(groupedHLines, groupedVLines, width, height, data, combinedEdges);
            
            // === SPRAWDZENIE: Czy znaleziono prawdziwy prostokƒÖt? ===
            if (!bestFrame) {
                console.log('‚ö†Ô∏è No proper rectangle found (no 4/4 connected corners)');
                console.log('üì¶ Falling back to content bounding box detection...');
                
                const bbox = detectContentBBox(ctx, width, height);
                
                if (bbox) {
                    console.log(`‚úì Using content bbox: x=${Math.round(bbox.x)}, y=${Math.round(bbox.y)}, ` +
                               `w=${Math.round(bbox.width)}, h=${Math.round(bbox.height)}`);
                    
                    return {
                        x: bbox.x,
                        y: bbox.y,
                        width: bbox.width,
                        height: bbox.height,
                        debugInfo: {
                            hLinesCount: horizontalLines.length,
                            vLinesCount: verticalLines.length,
                            topY: bbox.y,
                            bottomY: bbox.y + bbox.height,
                            leftX: bbox.x,
                            rightX: bbox.x + bbox.width,
                            fallbackMethod: 'contentBBox'
                        }
                    };
                } else {
                    console.log('‚ö†Ô∏è Content bbox also failed, using full page');
                    return {
                        x: 0, y: 0, width: width, height: height,
                        debugInfo: {
                            hLinesCount: horizontalLines.length,
                            vLinesCount: verticalLines.length,
                            topY: 0, bottomY: height, leftX: 0, rightX: width,
                            fallbackMethod: 'fullPage'
                        }
                    };
                }
            }
            
            console.log(`‚úì Best frame: x=${Math.round(bestFrame.x)}, y=${Math.round(bestFrame.y)}, ` +
                       `w=${Math.round(bestFrame.width)}, h=${Math.round(bestFrame.height)}`);
            
            return {
                x: bestFrame.x,
                y: bestFrame.y,
                width: bestFrame.width,
                height: bestFrame.height,
                debugInfo: {
                    hLinesCount: horizontalLines.length,
                    vLinesCount: verticalLines.length,
                    topY: bestFrame.y,
                    bottomY: bestFrame.y + bestFrame.height,
                    leftX: bestFrame.x,
                    rightX: bestFrame.x + bestFrame.width
                }
            };
        }


        function detectContentBBox(ctx, width, height) {
            const imageData = ctx.getImageData(0, 0, width, height);
            const data = imageData.data;
            
            const threshold = 240;
            
            let minX = width, maxX = 0;
            let minY = height, maxY = 0;
            
            for (let y = 0; y < height; y++) {
                for (let x = 0; x < width; x++) {
                    const i = (y * width + x) * 4;
                    const r = data[i];
                    const g = data[i + 1];
                    const b = data[i + 2];
                    
                    if (r < threshold || g < threshold || b < threshold) {
                        if (x < minX) minX = x;
                        if (x > maxX) maxX = x;
                        if (y < minY) minY = y;
                        if (y > maxY) maxY = y;
                    }
                }
            }
            
            const padding = 20;
            return {
                x: Math.max(0, minX - padding),
                y: Math.max(0, minY - padding),
                width: Math.min(width, maxX - minX + 2 * padding),
                height: Math.min(height, maxY - minY + 2 * padding)
            };
        }

        async function renderCurrentPage() {
            const scale = 3.0;

            // === RENDERUJ OBA PDF-y ===
            const oldPage = await oldDoc.getPage(currentPage);
            const oldViewport = oldPage.getViewport({scale: scale});
            
            const tempOldCanvas = document.createElement('canvas');
            tempOldCanvas.width = oldViewport.width;
            tempOldCanvas.height = oldViewport.height;
            const tempOldCtx = tempOldCanvas.getContext('2d');
            await oldPage.render({canvasContext: tempOldCtx, viewport: oldViewport}).promise;
            
            const newPage = await newDoc.getPage(currentPage);
            const newViewport = newPage.getViewport({scale: scale});
            
            const tempNewCanvas = document.createElement('canvas');
            tempNewCanvas.width = newViewport.width;
            tempNewCanvas.height = newViewport.height;
            const tempNewCtx = tempNewCanvas.getContext('2d');
            await newPage.render({canvasContext: tempNewCtx, viewport: newViewport}).promise;

            if (alignmentData) {
                // === KRYTYCZNE: OBA CANVASY TEN SAM ROZMIAR ===
                // Oblicz maksymalny rozmiar potrzebny dla obu
                const scaleX = alignmentData.scaleX;
                const scaleY = alignmentData.scaleY;
                const offsetX = alignmentData.shiftX;
                const offsetY = alignmentData.shiftY;
                
                // Rozmiar OLD po transformacji
                const oldTransformedW = tempOldCanvas.width * scaleX;
                const oldTransformedH = tempOldCanvas.height * scaleY;
                
                // Maksymalna szeroko≈õƒá/wysoko≈õƒá potrzebna
                const maxWidth = Math.max(
                    tempNewCanvas.width,
                    Math.abs(offsetX) + oldTransformedW
                );
                const maxHeight = Math.max(
                    tempNewCanvas.height,
                    Math.abs(offsetY) + oldTransformedH
                );
                
                console.log('‚ïî‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïó');
                console.log('‚ïë  CANVAS DIMENSIONS             ‚ïë');
                console.log('‚ïö‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïù');
                console.log('OLD original:', tempOldCanvas.width, 'x', tempOldCanvas.height);
                console.log('OLD transformed:', oldTransformedW.toFixed(0), 'x', oldTransformedH.toFixed(0));
                console.log('NEW:', tempNewCanvas.width, 'x', tempNewCanvas.height);
                console.log('FINAL canvas size:', maxWidth.toFixed(0), 'x', maxHeight.toFixed(0));
                console.log('Transform: scale', scaleX.toFixed(4), 'x', scaleY.toFixed(4), 'offset', offsetX.toFixed(2), ',', offsetY.toFixed(2));
                
                // === OLD CANVAS: TEN SAM ROZMIAR CO NEW ===
                const oldCanvas = document.getElementById('oldCanvas');
                oldCanvas.width = maxWidth;
                oldCanvas.height = maxHeight;
                const oldCtx = oldCanvas.getContext('2d');
                
                // Transformuj i rysuj OLD
                oldCtx.save();
                oldCtx.translate(offsetX, offsetY);
                oldCtx.scale(scaleX, scaleY);
                oldCtx.drawImage(tempOldCanvas, 0, 0);
                oldCtx.restore();
                
                // === NEW CANVAS: TEN SAM ROZMIAR ===
                const newCanvas = document.getElementById('newCanvas');
                newCanvas.width = maxWidth;
                newCanvas.height = maxHeight;
                const newCtx = newCanvas.getContext('2d');
                newCtx.drawImage(tempNewCanvas, 0, 0);
                
                console.log('‚úÖ OBA canvasy majƒÖ rozmiar:', maxWidth, 'x', maxHeight);
                console.log('‚úÖ Ramki powinny byƒá DOK≈ÅADNIE NA≈ÅO≈ªONE');
                
                // Ramki dla weryfikacji
                if (showFrames) {
                    const newF = alignmentData.newF;
                    
                    // ≈ª√≥≈Çta ramka na OLD (po transformacji powinna byƒá w miejscu newF)
                    oldCtx.strokeStyle = 'yellow';
                    oldCtx.lineWidth = 4;
                    oldCtx.strokeRect(newF.x, newF.y, newF.w, newF.h);
                    
                    // Cyan ramka na NEW
                    newCtx.strokeStyle = 'cyan';
                    newCtx.lineWidth = 4;
                    newCtx.strokeRect(newF.x, newF.y, newF.w, newF.h);
                    
                    console.log('üì¶ Ramki narysowane na:', newF.x.toFixed(0), ',', newF.y.toFixed(0), 
                               newF.w.toFixed(0), 'x', newF.h.toFixed(0));
                }
            } else {
                // Bez alignment - tylko poka≈º orygina≈Çy
                const oldCanvas = document.getElementById('oldCanvas');
                oldCanvas.width = tempOldCanvas.width;
                oldCanvas.height = tempOldCanvas.height;
                oldCanvas.getContext('2d').drawImage(tempOldCanvas, 0, 0);
                
                const newCanvas = document.getElementById('newCanvas');
                newCanvas.width = tempNewCanvas.width;
                newCanvas.height = tempNewCanvas.height;
                newCanvas.getContext('2d').drawImage(tempNewCanvas, 0, 0);
            }

            updatePageInfo();
            addPanControls();
            applyTransform();
        }

        function updatePageInfo() {
            document.getElementById('pageInfo').textContent = `Strona ${currentPage} z ${totalPages}`;
        }

        function updateAlignmentInfo() {
            if (alignmentData) {
                document.getElementById('offsetX').textContent = alignmentData.shiftX.toFixed(2);
                document.getElementById('offsetY').textContent = alignmentData.shiftY.toFixed(2);
                document.getElementById('scaleX').textContent = alignmentData.scaleX.toFixed(4);
                document.getElementById('scaleY').textContent = alignmentData.scaleY.toFixed(4);
            }
        }

        function updateDebugInfo() {
            document.getElementById('hLinesCount').textContent = 
                `OLD:${debugInfo.oldHLines} NEW:${debugInfo.newHLines}`;
            document.getElementById('vLinesCount').textContent = 
                `OLD:${debugInfo.oldVLines} NEW:${debugInfo.newVLines}`;
            
            if (debugInfo.oldFrame) {
                document.getElementById('oldFrameInfo').textContent = 
                    `${Math.round(debugInfo.oldFrame.x)},${Math.round(debugInfo.oldFrame.y)} ${Math.round(debugInfo.oldFrame.width)}x${Math.round(debugInfo.oldFrame.height)}`;
            }
            if (debugInfo.newFrame) {
                document.getElementById('newFrameInfo').textContent = 
                    `${Math.round(debugInfo.newFrame.x)},${Math.round(debugInfo.newFrame.y)} ${Math.round(debugInfo.newFrame.width)}x${Math.round(debugInfo.newFrame.height)}`;
            }
        }

        function toggleAuto() {
            const btn = document.getElementById('autoBtn');
            if (autoToggleInterval) {
                clearInterval(autoToggleInterval);
                autoToggleInterval = null;
                btn.textContent = '‚ñ∂Ô∏è Auto Toggle';
                btn.classList.remove('active');
            } else {
                const speed = parseInt(document.getElementById('toggleSpeed').value);
                autoToggleInterval = setInterval(() => {
                    manualToggle();
                }, speed);
                btn.textContent = '‚è∏Ô∏è Stop Auto';
                btn.classList.add('active');
            }
        }

        function manualToggle() {
            showingOld = !showingOld;
            const oldContainer = document.getElementById('oldCanvasContainer');
            const newContainer = document.getElementById('newCanvasContainer');
            
            if (showingOld) {
                oldContainer.style.visibility = 'visible';
                newContainer.style.visibility = 'hidden';
            } else {
                oldContainer.style.visibility = 'hidden';
                newContainer.style.visibility = 'visible';
            }
        }

        function updateToggleSpeed() {
            const value = document.getElementById('toggleSpeed').value;
            document.getElementById('toggleSpeedValue').textContent = value;
            
            if (autoToggleInterval) {
                toggleAuto(); // Stop
                toggleAuto(); // Restart with new speed
            }
        }

        function updateThreshold() {
            edgeThreshold = parseInt(document.getElementById('edgeThreshold').value);
            gapTolerance = parseInt(document.getElementById('gapTolerance').value);
            lineThreshold = parseInt(document.getElementById('lineThreshold').value) / 100;
            
            document.getElementById('edgeThresholdValue').textContent = edgeThreshold;
            document.getElementById('gapToleranceValue').textContent = gapTolerance;
            document.getElementById('lineThresholdValue').textContent = Math.round(lineThreshold * 100);
        }

        async function recalculateAlignment() {
            document.getElementById('loading').style.display = 'block';
            document.getElementById('comparisonSection').style.display = 'none';
            
            await calculateAlignment();
            await renderCurrentPage();
            
            document.getElementById('loading').style.display = 'none';
            document.getElementById('comparisonSection').style.display = 'block';
            
            // Automatically show frames after recalculation
            if (!showFrames) {
                showFrames = true;
                document.getElementById('frameVisBtn').textContent = 'üëÅÔ∏è Ukryj Ramki';
                document.getElementById('frameVisBtn').classList.add('active');
            }
            drawFrameOverlays();
        }

        function toggleFrameVisualization() {
            showFrames = !showFrames;
            const btn = document.getElementById('frameVisBtn');
            
            if (showFrames) {
                btn.textContent = 'üëÅÔ∏è Ukryj Ramki';
                btn.classList.add('active');
            } else {
                btn.textContent = 'üëÅÔ∏è Poka≈º Ramki';
                btn.classList.remove('active');
            }
            
            // Ramki sƒÖ teraz na canvas, wiƒôc musimy re-renderowaƒá
            renderCurrentPage();
        }

        function drawFrameOverlays() {
            // Ramki sƒÖ teraz rysowane bezpo≈õrednio w renderCurrentPage()
            // Ta funkcja nie jest ju≈º potrzebna
            console.log('Frames are drawn in renderCurrentPage()');
        }

        function removeFrameOverlays() {
            document.querySelectorAll('.frame-overlay').forEach(el => el.remove());
        }

        function updateZoom() {
            currentZoom = parseInt(document.getElementById('zoomSlider').value) / 100;
            document.getElementById('zoomValue').textContent = Math.round(currentZoom * 100);
            applyTransform();
        }

        function rotateMap(degrees) {
            currentRotation = (currentRotation + degrees) % 360;
            if (currentRotation < 0) currentRotation += 360;
            applyTransform();
        }

        function applyTransform() {
            if (!alignmentData) return;
            
            const containers = document.querySelectorAll('.canvas-container');
            const oldContainer = containers[0];
            const newContainer = containers[1];
            
            // PROSTE: tylko center + user controls (zoom + rotate)
            // Alignment jest ju≈º zrobiony w canvas przez drawImage!
            
            oldContainer.style.transform = `
                translate(-50%, -50%)
                rotate(${currentRotation}deg)
                scale(${currentZoom})
            `;
            
            newContainer.style.transform = `
                translate(-50%, -50%)
                rotate(${currentRotation}deg)
                scale(${currentZoom})
            `;
            
            console.log('‚úì User controls applied (zoom:', currentZoom, 'rotation:', currentRotation, ')');
        }

        function resetView() {
            currentZoom = 1.0;
            currentRotation = 0;
            panOffsetX = 0;
            panOffsetY = 0;
            document.getElementById('zoomSlider').value = 100;
            document.getElementById('zoomValue').textContent = '100';
            applyTransform();
        }

        function addPanControls() {
            const wrapper = document.getElementById('viewerWrapper');
            const containers = document.querySelectorAll('.canvas-container');
            
            containers.forEach(container => {
                container.addEventListener('mousedown', (e) => {
                    isPanning = true;
                    panStartX = e.clientX - panOffsetX;
                    panStartY = e.clientY - panOffsetY;
                });
            });
            
            wrapper.addEventListener('mousemove', (e) => {
                if (!isPanning) return;
                panOffsetX = e.clientX - panStartX;
                panOffsetY = e.clientY - panStartY;
                containers.forEach(container => {
                    container.style.left = `calc(50% + ${panOffsetX}px)`;
                    container.style.top = `calc(50% + ${panOffsetY}px)`;
                });
            });
            
            wrapper.addEventListener('mouseup', () => {
                isPanning = false;
            });
            
            wrapper.addEventListener('mouseleave', () => {
                isPanning = false;
            });
            
            // Wheel zoom
            wrapper.addEventListener('wheel', (e) => {
                e.preventDefault();
                const delta = e.deltaY > 0 ? 0.9 : 1.1;
                scale *= delta;
                scale = Math.max(0.5, Math.min(3, scale)); // Limit 0.5x - 3x
                
                containers.forEach(container => {
                    container.style.transform = `translate(-50%, -50%) scale(${scale})`;
                });
            }, { passive: false });
        }

        function prevPage() {
            if (currentPage > 1) {
                currentPage--;
                renderCurrentPage();
            }
        }

        function nextPage() {
            if (currentPage < totalPages) {
                currentPage++;
                renderCurrentPage();
            }
        }

        function resetAndUpload() {
            if (autoToggleInterval) clearInterval(autoToggleInterval);
            
            oldFile = null;
            newFile = null;
            oldDoc = null;
            newDoc = null;
            currentPage = 1;
            showingOld = true;
            alignmentData = null;
            
            document.getElementById('comparisonSection').style.display = 'none';
            document.getElementById('uploadSection').style.display = 'block';
            document.getElementById('oldFileName').textContent = 'Nie za≈Çadowano';
            document.getElementById('newFileName').textContent = 'Nie za≈Çadowano';
            document.getElementById('startButtonContainer').style.display = 'none';
            
            // Reset progress bar
            document.getElementById('progressBar').style.width = '0%';
            document.getElementById('progressText').textContent = '0%';
            
            resetView();
        }
    </script>

</body>
</html>
